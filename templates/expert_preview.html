<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Expert Preview - Video Question Review</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            min-height: 100vh;
            color: #2d3748;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .video-selector {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        select {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            min-width: 200px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: #3182ce;
            color: white;
        }
        
        .btn:hover {
            background: #2c5aa0;
            transform: translateY(-1px);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            min-height: 600px;
        }
        
        .video-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .video-section.qs-fullscreen-active,
        .qs-fullscreen .video-section {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            background: #0f172a;
        }
        
        .video-section.qs-fullscreen-active .video-container,
        .qs-fullscreen .video-section .video-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .video-section.qs-fullscreen-active .video-player,
        .qs-fullscreen .video-section .video-player {
            flex: 1;
            width: 100%;
            height: 100%;
        }
        
        .video-section.qs-fullscreen-active .questions-panel,
        .qs-fullscreen .video-section .questions-panel {
            max-height: 35vh;
            overflow-y: auto;
        }
        
        .video-player.qs-fullscreen-video,
        .qs-fullscreen video {
            width: 100%;
            height: 100%;
        }
        
        .video-container {
            position: relative;
        }
        
        .video-player {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            background: #000;
        }
        
        .video-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 500px;
            background: #f8f9fa;
            color: #718096;
            font-size: 1.1rem;
            border-radius: 8px;
        }
        
        /* Timeline pause point annotations */
        .timeline-annotations {
            position: absolute;
            bottom: 35px;
            left: 0;
            right: 0;
            height: 4px;
            margin: 0 15px;
            pointer-events: none;
            z-index: 15;
        }
        
        .timeline-pause-point {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            background: #ff6b6b;
            top: -4px;
            transform: translateX(-50%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
        }
        
        .timeline-pause-point.completed {
            background: #51cf66;
            border-color: #38a169;
        }
        
        .timeline-pause-point.current {
            background: #ffd43b;
            border-color: #d69e2e;
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 15px rgba(255,212,59,0.9);
        }
        
        .video-controls {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .time-display {
            font-family: monospace;
            font-size: 1.1rem;
            font-weight: bold;
            color: #3182ce;
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .btn-sm {
            padding: 8px 16px;
            font-size: 0.9rem;
        }
        
        .btn-secondary {
            background: #718096;
        }
        
        .btn-secondary:hover {
            background: #4a5568;
        }
        
        .btn-danger {
            background: #e53e3e;
        }
        
        .btn-danger:hover {
            background: #c53030;
        }
        
        .btn-light {
            background: #edf2f7;
            color: #2d3748;
        }
        
        .btn-light:hover {
            background: #e2e8f0;
        }
        
        /* Manual Add Question Modal */
        .add-question-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .add-question-modal.active {
            display: flex;
        }
        
        .add-question-content {
            background: white;
            padding: 32px;
            border-radius: 14px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 12px 40px rgba(0,0,0,0.35);
        }
        
        .add-question-header {
            margin-bottom: 24px;
        }
        
        .add-question-header h3 {
            margin: 0 0 8px 0;
            color: #2d3748;
            font-size: 1.4rem;
        }
        
        .add-question-header p {
            margin: 0;
            color: #4a5568;
            font-size: 0.95rem;
        }
        
        .timestamp-display {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding: 12px;
            background: #f7fafc;
            border-radius: 8px;
        }
        
        .timestamp-label {
            font-weight: 600;
            color: #2d3748;
        }
        
        .timestamp-value {
            font-family: monospace;
            font-size: 1.1rem;
            color: #3182ce;
        }
        
        .timestamp-input {
            padding: 6px 10px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            font-family: monospace;
            font-size: 1rem;
        }
        
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            z-index: 20;
        }
        
        .pause-overlay.active {
            display: flex;
        }
        
        .pause-message {
            background: white;
            padding: 32px;
            border-radius: 14px;
            max-width: 560px;
            width: 100%;
            box-shadow: 0 12px 40px rgba(0,0,0,0.35);
            display: flex;
            flex-direction: column;
            gap: 16px;
            text-align: left;
        }

        .pause-message h3 {
            margin: 0;
            color: #2d3748;
            font-size: 1.4rem;
        }

        .pause-message p {
            margin: 0;
            color: #4a5568;
            font-size: 0.95rem;
        }

        .pause-hint {
            font-size: 0.9rem;
            color: #4a5568;
        }

        .pause-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .pause-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .pause-field label {
            font-weight: 600;
            font-size: 0.9rem;
            color: #2d3748;
        }

        .pause-field select,
        .pause-field textarea,
        .pause-field input {
            padding: 10px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            font-size: 0.95rem;
            font-family: inherit;
            resize: vertical;
        }

        .pause-field textarea {
            min-height: 80px;
        }

        .pause-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 4px;
        }

        .form-feedback {
            min-height: 18px;
            font-size: 0.85rem;
            color: #e53e3e;
        }

        .form-feedback.success {
            color: #2f855a;
        }
        
        .questions-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: none;
            margin-top: 20px;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .segment-info {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .segment-time {
            font-family: monospace;
            font-size: 1.2rem;
            font-weight: bold;
            color: #3182ce;
            margin-bottom: 5px;
        }
        
        .segment-duration {
            color: #718096;
            font-size: 0.9rem;
        }
        
        .ai-questions {
            margin-bottom: 25px;
        }
        
        .question-item {
            background: #f8f9fa;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .question-item.skipped {
            background: #fffaf0;
            border: 1px solid #fbd38d;
        }

        .question-item.skipped .question-type-badge {
            background: #dd6b20;
        }

        .question-meta {
            font-size: 0.8rem;
            color: #718096;
            margin-top: 8px;
        }

        .question-type-badge {
            display: inline-block;
            background: #3182ce;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .question-text {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2d3748;
        }
        
        .answer-text {
            color: #718096;
            margin-bottom: 15px;
        }
        
        .progress-indicator {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #38a169;
            transition: width 0.3s ease;
        }
        
        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }
        
        .status-success {
            background: #f0fff4;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }
        
        .status-error {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #fc8181;
        }
        
        .status-info {
            background: #ebf4ff;
            color: #2b6cb0;
            border: 1px solid #90cdf4;
        }
        
        .approve-section {
            background: #f0fff4;
            border: 2px solid #38a169;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .btn-success {
            background: #38a169;
            color: white;
        }
        
        .btn-success:hover {
            background: #2f855a;
        }
        
        .page-header {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            color: #2d3748;
        }
        .page-header h1 {
            margin-bottom: 8px;
        }
        .page-header p {
            color: #4a5568;
            font-size: 0.95rem;
        }
        .steps {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .step {
            flex: 1;
            min-width: 200px;
            position: relative;
            background: rgba(255,255,255,0.85);
            border-radius: 12px;
            padding: 16px 20px;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .step::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -12px;
            width: 24px;
            height: 2px;
            background: rgba(255,255,255,0.4);
            transform: translateY(-50%);
        }
        .steps .step:last-child::after {
            display: none;
        }
        .step .step-number {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: #e2e8f0;
            color: #2d3748;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
        }
        .step-text {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .step-label {
            font-weight: 600;
        }
        .step-subtitle {
            font-size: 0.85rem;
            color: #4a5568;
        }
        .step.step-disabled {
            cursor: not-allowed;
            opacity: 0.65;
        }
        .step.active {
            background: #3182ce;
            border-color: #3182ce;
            color: white;
        }
        .step.active .step-number {
            background: white;
            color: #3182ce;
        }
        .step.completed {
            background: rgba(56,161,105,0.12);
            border-color: #38a169;
            color: #22543d;
        }
        .step.completed .step-number {
            background: #38a169;
            color: white;
        }
        .step-content {
            display: none;
        }
        .step-content.active {
            display: block;
            animation: fadeIn 0.25s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .status-stack {
            margin-bottom: 20px;
        }
        .selection-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .selection-help {
            color: #4a5568;
            font-size: 0.95rem;
        }
        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }
        .selection-text {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .video-card-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
        }
        .video-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .video-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(49, 130, 206, 0.1);
            border-color: #3182ce;
        }
        .video-card.selected {
            border-color: #3182ce;
            background: #ebf8ff;
            box-shadow: 0 12px 28px rgba(49, 130, 206, 0.15);
        }
        .video-card.loading {
            opacity: 0.7;
            pointer-events: none;
        }
        .video-card-thumb {
            position: relative;
            width: 100%;
            padding-top: 56%;
            border-radius: 8px;
            overflow: hidden;
            background: #dbe3f2;
        }
        .video-card-thumb-image {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .video-card-thumb-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4c51bf, #3182ce);
            color: #f7fafc;
            font-size: 1.6rem;
            font-weight: 700;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }
        .video-card-duration-badge {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(26, 32, 44, 0.8);
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 999px;
        }
        .video-card-details {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .video-card-title {
            font-weight: 600;
            color: #2d3748;
            margin: 0;
        }
        .video-card-subtitle {
            font-size: 0.85rem;
            color: #4a5568;
            margin: 0;
        }
        .video-card-meta {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.85rem;
            color: #4a5568;
        }
        .video-list-empty {
            grid-column: 1 / -1;
            text-align: center;
            color: #718096;
            padding: 20px;
            background: #f7fafc;
            border: 1px dashed #cbd5e0;
            border-radius: 10px;
        }
        .review-button-bar {
            display: flex;
            justify-content: flex-end;
            margin-top: 10px;
        }
        .review-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .review-card h2 {
            margin-bottom: 10px;
        }
        .review-meta {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 0.95rem;
            color: #4a5568;
            margin-bottom: 20px;
        }
        .review-questions-list {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        /* Accordion styles */
        .accordion-item {
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 8px;
            overflow: hidden;
            background: white;
        }
        
        .accordion-header {
            padding: 16px 20px;
            background: #f7fafc;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        .accordion-header:hover {
            background: #edf2f7;
        }
        
        .accordion-header.active {
            background: #3182ce;
            color: white;
        }
        
        .accordion-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .accordion-arrow {
            transition: transform 0.3s;
            font-size: 1.2rem;
        }
        
        .accordion-header.active .accordion-arrow {
            transform: rotate(180deg);
        }
        
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .accordion-content.active {
            max-height: 2000px;
        }
        
        .accordion-inner {
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .question-column {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
        }
        
        .column-header {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .expert-column {
            background: #f0fff4;
        }
        
        .llm-column {
            background: #f7fafc;
        }
        
        .editable-question {
            margin-bottom: 16px;
            padding: 12px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            position: relative;
        }
        
        .editable-question.collapsed {
            padding: 10px 12px;
        }
        
        .editable-question.best-question {
            background: #fef5e7;
            border: 2px solid #f39c12;
        }
        
        .editable-question.trashed {
            opacity: 0.5;
            background: #fed7d7;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }
        
        .question-summary {
            flex: 1;
            cursor: pointer;
        }
        
        .question-type-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: #4a5568;
            margin-bottom: 4px;
            font-weight: 600;
            display: inline-block;
        }
        
        .best-indicator {
            display: inline-block;
            background: #f39c12;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .question-preview {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 4px;
            line-height: 1.4;
        }
        
        .answer-preview {
            color: #718096;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .question-field {
            margin-bottom: 10px;
            display: none;
        }
        
        .editable-question.editing .question-field {
            display: block;
            margin-top: 12px;
        }
        
        .editable-question.editing .question-summary {
            display: none;
        }
        
        .question-field label {
            display: block;
            font-size: 0.85rem;
            color: #718096;
            margin-bottom: 4px;
        }
        
        .question-field input,
        .question-field textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .question-field textarea {
            min-height: 60px;
        }
        
        .question-actions {
            display: flex;
            gap: 8px;
        }
        
        .btn-icon {
            padding: 6px 12px;
            font-size: 0.85rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-edit {
            background: #3182ce;
            color: white;
        }
        
        .btn-edit:hover {
            background: #2c5aa0;
        }
        
        .btn-trash {
            background: #fc8181;
            color: white;
        }
        
        .btn-trash:hover {
            background: #f56565;
        }
        
        .btn-restore {
            background: #48bb78;
            color: white;
        }
        
        .btn-restore:hover {
            background: #38a169;
        }
        
        .btn-save-edit {
            background: #38a169;
            color: white;
        }
        
        .btn-save-edit:hover {
            background: #2f855a;
        }
        
        .btn-cancel-edit {
            background: #718096;
            color: white;
        }
        
        .btn-cancel-edit:hover {
            background: #4a5568;
        }
        
        .btn-save-changes {
            background: #3182ce;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 20px;
        }
        
        .accordion-header.approved {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .accordion-header.approved .segment-index::after {
            content: " ?";
            color: #28a745;
            font-weight: bold;
        }
        
        .segment-approve-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e2e8f0;
            text-align: center;
        }
        
        .btn-approve-segment {
            background: #28a745;
            color: white;
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .btn-approve-segment:hover {
            background: #218838;
        }
        
        .btn-approve-segment:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .expert-question-display {
            background: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        
        .expert-question-display.skipped {
            background: #fffaf0;
            border: 1px solid #fbd38d;
        }

        .review-placeholder {
            text-align: center;
            color: #718096;
            padding: 20px;
            background: #fff;
            border-radius: 8px;
            border: 1px dashed #cbd5e0;
        }
        .review-actions {
            margin-top: 24px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        @media (max-width: 900px) {
            .steps {
                flex-direction: column;
            }
            .step::after {
                display: none;
            }
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .questions-panel {
                max-height: 600px;
            }
        }
        
        @media (max-width: 768px) {
            .video-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .control-buttons {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .selection-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .video-card-list {
                grid-template-columns: 1fr;
            }
        }
            .llm-review-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 24px;
            background: rgba(45, 55, 72, 0.6);
            z-index: 1600;
        }

        .llm-review-modal.active {
            display: flex;
        }

        .llm-review-content {
            width: min(920px, 95%);
            max-height: 90vh;
            overflow-y: auto;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
            padding: 28px 32px;
        }

        .llm-review-header h3 {
            margin: 0 0 6px;
            font-size: 1.4rem;
            color: #2d3748;
        }

        .llm-review-header p {
            margin: 0;
            color: #4a5568;
            font-size: 0.95rem;
        }

        .llm-modal-feedback {
            color: #c53030;
            font-size: 0.95rem;
            margin-bottom: 12px;
        }

        .llm-step-instructions {
            background: #ebf8ff;
            border: 1px solid #bee3f8;
            color: #2b6cb0;
            padding: 12px 14px;
            border-radius: 8px;
            font-size: 0.95rem;
            margin-bottom: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .llm-instruction-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2b6cb0;
            color: #fff;
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: none;
        }
        
        .llm-instruction-text {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-style: italic;
            font-weight: 700;
            color: inherit;
        }

        .llm-step-content {
            display: none;
        }

        .llm-step-content.active {
            display: block;
        }

        .llm-step-grid {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .llm-step-stack {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        
        .llm-section-box {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 16px;
        }
        
        .llm-trashed-section {
            background: #fff5f5;
            border-color: #feb2b2;
        }
        
        .llm-inline-trash {
            background: #fff5f5;
            border: 1px solid #feb2b2;
            border-radius: 10px;
            padding: 16px;
            transition: border-color 0.2s ease, background 0.2s ease;
        }
        
        .llm-inline-trash.drag-over {
            border-style: dashed;
            border-color: #fc8181;
            background: #fff0f0;
        }

        .llm-ranking-column,
        .llm-trash-column {
            flex: 1 1 300px;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 16px;
            min-height: 220px;
        }

        .llm-triage-list,
        .llm-triage-trash-list,
        .llm-ranking-list,
        .llm-trash-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .llm-triage-item,
        .llm-ranking-item,
        .llm-trash-item {
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 10px;
            background: #ffffff;
            transition: box-shadow 0.2s ease;
        }
        
        .llm-triage-item {
            cursor: default;
        }
        
        .llm-ranking-item {
            cursor: grab;
        }
        
        .llm-ranking-item:active {
            cursor: grabbing;
        }
        
        .llm-trash-item {
            cursor: default;
            border-color: #fc8181;
            background: #fff5f5;
        }
        
        .llm-trash-item .llm-item-type {
            color: #c53030;
        }
        
        .llm-trash-item .llm-item-question {
            color: #742a2a;
        }
        
        .llm-triage-actions {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .llm-rank-badge {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #3182ce;
            color: #ffffff;
            display: grid;
            place-items: center;
            font-weight: 600;
        }

        .llm-item-text {
            flex: 1;
        }

        .llm-item-type {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            color: #4a5568;
            margin-bottom: 4px;
        }

        .llm-item-question {
            color: #1a202c;
            font-size: 0.95rem;
        }

        .llm-trash-dropzone {
            border: none;
            padding: 0;
        }

        .llm-triage-empty,
        .llm-triage-trash-empty,
        .llm-ranking-empty,
        .llm-trash-empty,
        .llm-empty-state {
            text-align: center;
            color: #718096;
            font-size: 0.9rem;
            padding: 16px;
        }

        .llm-comment-section {
            margin-top: 18px;
        }

        .llm-comment-section label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            color: #2d3748;
        }

        .llm-comment-section textarea {
            width: 100%;
            min-height: 90px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.95rem;
            resize: vertical;
        }

        .llm-step-footer {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .llm-accordion {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .llm-accordion-item {
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            background: #ffffff;
            overflow: hidden;
        }

        .llm-accordion-item.trashed {
            border-color: #fc8181;
            background: #fff5f5;
        }

        .llm-accordion-header {
            width: 100%;
            background: transparent;
            border: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 18px;
            text-align: left;
            cursor: pointer;
            font-size: 1rem;
        }

        .llm-accordion-item.open .llm-accordion-header {
            background: #ebf8ff;
        }

        .llm-accordion-title {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .llm-accordion-panel {
            display: none;
            padding: 18px;
            border-top: 1px solid #e2e8f0;
        }

        .llm-accordion-item.open .llm-accordion-panel {
            display: block;
        }

        .llm-answer-display {
            padding: 12px 14px;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }

        .llm-answer-display strong {
            display: block;
            font-size: 0.8rem;
            color: #4a5568;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            margin-bottom: 6px;
        }

        .llm-answer-text {
            color: #2d3748;
            white-space: pre-wrap;
        }

        .llm-answer-empty {
            color: #718096;
            font-style: italic;
        }

        .llm-accordion-actions {
            margin-top: 14px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .llm-edit-form {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .llm-modal-field label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .llm-modal-field textarea {
            width: 100%;
            min-height: 80px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.95rem;
            resize: vertical;
        }

        .llm-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        @media (max-width: 900px) {
            .llm-review-content {
                width: 100%;
                max-height: 85vh;
                padding: 20px;
            }
            .llm-step-grid {
                flex-direction: column;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="page-header">
            <h1>Expert Preview - Video Question Review</h1>
            <p>Walk through the downloaded video, refine each AI segment, and prepare the final set of comprehension questions.</p>
        </div>

        <div class="steps" id="expert-steps">
            <div class="step active" data-step="1">
                <div class="step-number">1</div>
                <div class="step-text">
                    <div class="step-label">Select a Video</div>
                    <div class="step-subtitle">Choose from the downloads folder</div>
                </div>
            </div>
            <div class="step step-disabled" data-step="2">
                <div class="step-number">2</div>
                <div class="step-text">
                    <div class="step-label">Add Questions</div>
                    <div class="step-subtitle">Play, pause, and approve segments</div>
                </div>
            </div>
            <div class="step step-disabled" data-step="3">
                <div class="step-number">3</div>
                <div class="step-text">
                    <div class="step-label">Review Questions</div>
                    <div class="step-subtitle">Check the full question set</div>
                </div>
            </div>
        </div>

        <div id="global-status-messages" class="status-stack"></div>

        <div class="step-content active" id="step-1" data-step="1">
            <div class="selection-card">
                <div class="selection-header">
                    <div class="selection-text">
                        <h2>Select a video to review</h2>
                        <p class="selection-help">Pick a processed video from the downloads folder to preview and refine the AI-generated questions.</p>
                    </div>
                    <button class="btn" id="refresh-videos-btn" onclick="loadVideoList()">Refresh List</button>
                </div>
                <div id="video-card-list" class="video-card-list">
                    <div class="video-list-empty">Loading available videos...</div>
                </div>
            </div>
        </div>

        <div class="step-content" id="step-2" data-step="2">
            <div class="main-grid">
                <div class="video-section">
                    <div class="video-container">
                        <div id="video-container">
                            <div class="video-loading">
                                Select a video to begin
                            </div>
                        </div>
                        <div class="timeline-annotations" id="timeline-annotations" style="display: none;">
                            <!-- Timeline pause points will be added here -->
                        </div>
                        <div class="pause-overlay" id="pause-overlay">
                            <div class="pause-message">
                                <div>
                                    <h3>Add Expert Question</h3>
                                    <p class="pause-hint">Segment <span id="expert-segment-number">1</span> | <span id="expert-segment-time">00:00 - 00:59</span> | Paused at <span id="expert-pause-timestamp">00:00</span></p>
                                </div>
                                <form id="expert-question-form" class="pause-form">
                                    <div class="pause-field">
                                        <label for="expert-question-type">Question Type <span style="color: red;">*</span></label>
                                        <select id="expert-question-type" required>
                                            <option value="">Select a question type...</option>
                                            <option value="character">Character</option>
                                            <option value="setting">Setting</option>
                                            <option value="feeling">Feeling</option>
                                            <option value="action">Action</option>
                                            <option value="causal">Causal</option>
                                            <option value="outcome">Outcome</option>
                                            <option value="prediction">Prediction</option>
                                        </select>
                                    </div>
                                    <div class="pause-field">
                                        <label for="expert-question-text">Question <span style="color: red;">*</span></label>
                                        <textarea id="expert-question-text" placeholder="Enter your question (required)" required></textarea>
                                    </div>
                                    <div class="pause-field">
                                        <label for="expert-answer-text">Answer <span style="color: red;">*</span></label>
                                        <textarea id="expert-answer-text" placeholder="Enter the answer (required)" required></textarea>
                                    </div>
                                    <div class="form-feedback" id="expert-form-feedback"></div>
                                    <div class="pause-actions">
                                        <button type="button" class="btn btn-secondary" id="expert-skip-button">Skip Segment</button>
                                        <button type="submit" class="btn btn-success" id="expert-submit-button">Save Question</button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>
                    <div class="video-controls">
                        <div class="time-display" id="time-display">00:00 / 00:00</div>
                        <div class="control-buttons">
                            <button class="btn btn-secondary btn-sm" onclick="jumpToSegment(-1)">Previous</button>
                            <button class="btn btn-sm" id="play-pause-btn" onclick="togglePlayPause()">Play</button>
                            <button class="btn btn-secondary btn-sm" onclick="jumpToSegment(1)">Next</button>
                            <button class="btn btn-secondary btn-sm" onclick="seekVideo(-10)">-10s</button>
                            <button class="btn btn-secondary btn-sm" onclick="seekVideo(10)">+10s</button>
                        </div>
                    </div>
                    <div class="questions-panel">
                        <div class="panel-header">
                            <h3>Expert Questions:</h3>
                        </div>
                        <div class="progress-indicator">
                            <div id="progress-text">Select a video to begin</div>
                            <div class="progress-bar">
                                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="segment-info" id="segment-info" style="display: none;">
                            <div class="segment-time" id="segment-time">00:00 - 00:00</div>
                            <div class="segment-duration" id="segment-duration">Duration: 0 seconds</div>
                        </div>
                        <div class="ai-questions" id="expert-questions">
                            <!-- AI questions will be populated here -->
                        </div>
                        <div class="approve-section" id="approve-section" style="display: none;">
                            <h3>Ready to Approve?</h3>
                            <p>Review the questions above and click approve to continue to the next segment</p>
                            <button class="btn btn-success" onclick="approveAndContinue()">Approve & Continue</button>
                        </div>
                        <div class="review-button-bar">
                            <button class="btn" id="review-button" onclick="handleReviewQuestions()" disabled>Review Questions</button>
                        </div>
                        <div id="status-messages"></div>
                    </div>
                </div>
            </div>
            
            <!-- Manual Add Question Modal -->
            <div class="add-question-modal" id="add-question-modal">
                <div class="add-question-content">
                    <div class="add-question-header">
                        <h3>Add Expert Question</h3>
                        <p>Add a custom question at the current timestamp</p>
                    </div>
                    
                    <form id="manual-question-form">
                        <div class="timestamp-display">
                            <span class="timestamp-label">Timestamp:</span>
                            <input type="text" 
                                   class="timestamp-input" 
                                   id="manual-timestamp" 
                                   placeholder="0:00"
                                   pattern="^(?:(?:([0-9]+):)?([0-5]?[0-9]):)?([0-5]?[0-9])$"
                                   title="Enter time as MM:SS or HH:MM:SS"
                                   required>
                            <span class="timestamp-value" id="manual-timestamp-display" style="display: none;">00:00</span>
                        </div>
                        
                        <div class="pause-field">
                            <label for="manual-question-type">Question Type <span style="color: red;">*</span></label>
                            <select id="manual-question-type" required>
                                <option value="">Select a question type...</option>
                                <option value="character">Character</option>
                                <option value="setting">Setting</option>
                                <option value="feeling">Feeling</option>
                                <option value="action">Action</option>
                                <option value="causal">Causal</option>
                                <option value="outcome">Outcome</option>
                                <option value="prediction">Prediction</option>
                            </select>
                        </div>
                        
                        <div class="pause-field">
                            <label for="manual-question-text">Question <span style="color: red;">*</span></label>
                            <textarea id="manual-question-text" placeholder="Enter your question (required)" required></textarea>
                        </div>
                        
                        <div class="pause-field">
                            <label for="manual-answer-text">Answer <span style="color: red;">*</span></label>
                            <textarea id="manual-answer-text" placeholder="Enter the answer (required)" required></textarea>
                        </div>
                        
                        <div class="form-feedback" id="manual-form-feedback"></div>
                        
                        <div class="pause-actions">
                            <button type="button" class="btn btn-secondary" onclick="closeAddQuestionModal()">Cancel</button>
                            <button type="submit" class="btn btn-success">Save Question</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- LLM Review Modal -->
        <div class="llm-review-modal" id="llm-review-modal">
            <div class="llm-review-content">
                <div class="llm-review-header">
                    <h3 id="llm-modal-step-title">Review AI Questions</h3>
                    <p id="llm-modal-segment-label">Segment details</p>
                </div>
                <div class="llm-modal-feedback" id="llm-modal-feedback"></div>
                <div class="llm-step-content active" id="llm-step-1">
                    <p class="llm-step-instructions"><span class="llm-instruction-icon" aria-hidden="true">i</span><span class="llm-instruction-text"><strong><em>Review the AI generated questions, move inappropriate ones to trash, and optionally leave a note.</em></strong></span></p>
                    <div class="llm-step-stack">
                        <div class="llm-section-box">
                            <h4 class="llm-section-title">Questions</h4>
                            <p class="llm-section-help">Review each question. Use the trash button to remove anything that should not be ranked.</p>
                            <ul class="llm-triage-list" id="llm-triage-list"></ul>
                            <div class="llm-triage-empty" id="llm-triage-empty">No questions available.</div>
                        </div>
                        <div class="llm-section-box llm-trashed-section">
                            <h4 class="llm-section-title">Trashed Questions</h4>
                            <p class="llm-section-help">Trashed questions move to the bottom. Restore one if you change your mind.</p>
                            <ul class="llm-triage-trash-list" id="llm-triage-trash-list"></ul>
                            <div class="llm-triage-trash-empty" id="llm-triage-trash-empty">No questions in trash.</div>
                        </div>
                    </div>
                    <div class="llm-comment-section">
                        <label for="llm-triage-comment">Comment (optional)</label>
                        <textarea id="llm-triage-comment" placeholder="Add an optional note about removed questions."></textarea>
                    </div>
                    <div class="llm-step-footer">
                        <button type="button" class="btn btn-success" id="llm-step-next-btn">Next: Rank Questions</button>
                    </div>
                </div>
                <div class="llm-step-content" id="llm-step-2">
                    <p class="llm-step-instructions"><span class="llm-instruction-icon" aria-hidden="true">i</span><span class="llm-instruction-text"><strong><em>Rank the remaining comprehension questions, and leave an optional rationale.</em></strong></span></p>
                    <div class="llm-step-stack">
                        <div class="llm-section-box">
                            <h4 class="llm-section-title">Ranking</h4>
                            <p class="llm-section-help">Drag questions to reorder them. The rank badge shows the current position.</p>
                            <ul class="llm-ranking-list" id="llm-ranking-list"></ul>
                            <div class="llm-ranking-empty" id="llm-ranking-empty">No questions available to rank.</div>
                        </div>
                        <div class="llm-section-box llm-inline-trash" id="llm-trash-dropzone">
                            <h4 class="llm-section-title">Trashed Questions</h4>
                            <p class="llm-section-help">Drop a question here to remove it from the ranked list. Drag it back above to restore.</p>
                            <ul class="llm-trash-list" id="llm-ranking-trash-list"></ul>
                            <div class="llm-trash-empty" id="llm-ranking-trash-empty">No questions in trash.</div>
                        </div>
                    </div>
                    <div class="llm-comment-section">
                        <label for="llm-ranking-comment">Comment (optional)</label>
                        <textarea id="llm-ranking-comment" placeholder="Add an optional note about your ranking decisions."></textarea>
                    </div>
                    <div class="llm-step-footer">
                        <button type="button" class="btn btn-secondary" id="llm-step-back-btn">Back</button>
                        <button type="button" class="btn btn-success" id="llm-step-next-review-btn">Next: Edit Questions</button>
                    </div>
                </div>
                <div class="llm-step-content" id="llm-step-3">
                    <p class="llm-step-instructions"><span class="llm-instruction-icon" aria-hidden="true">i</span><span class="llm-instruction-text"><strong><em>Review answers & make final edits to both questions and answers</em></strong></span></p>
                    <div class="llm-accordion" id="llm-accordion-list"></div>
                    <div class="llm-step-footer">
                        <button type="button" class="btn btn-secondary" id="llm-step-edit-back-btn">Back</button>
                        <button type="button" class="btn btn-success" id="llm-review-submit-btn">Submit &amp; Continue</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="step-content" id="step-3" data-step="3">
            <div class="review-card">
                <h2>Review Questions</h2>
                <p class="selection-help">Inspect each segment and its questions before sharing them with learners.</p>
                <div class="review-meta">
                    <div><strong>Video:</strong> <span id="review-video-id">Not selected</span></div>
                    <div><strong>Total segments:</strong> <span id="review-total-segments">0</span></div>
                </div>
                <div class="review-questions-list" id="review-questions-list">
                    <div class="review-placeholder">Select a video on Step 1 and choose 'Review Questions' to view the full set.</div>
                </div>
            </div>
        </div>

    </div>
    
    <script>
        let currentVideoId = null;
        let videoElement = null;
        let currentSegments = [];
        let currentSegmentIndex = 0;
        let isVideoPaused = false;
        let autoAdvanceEnabled = true;
        let currentStep = 1;
        let maxAvailableStep = 1;
        let availableVideos = [];
        let currentVideoLabel = '';
        let isLoadingVideo = false;
        let expertQuestions = {};
        let expertSaveInProgress = false;
        let pendingSegmentIndices = [];
        let llmQuestionEdits = {}; // Store edits made to LLM questions
        let segmentApprovals = {}; // Store which segments have been approved
        let manualQuestionTimestamp = null; // Store timestamp for manual questions
        const REVIEW_TOLERANCE_BEFORE = 0.25;

        let llmModalState = {
            open: false,
            segmentKey: null,
            segmentIndex: null,
            questions: [],
            rankingOrder: [],
            trashOrder: [],
            openQuestionKey: null,
            draggingKey: null,
            dragSource: null,
            step: 1,
            editingKey: null,
            triageComment: '',
            rankingComment: ''
        };
        let modalPlaybackLockCount = 0;
        let modalPlaybackWasPlaying = false;

        let llmModalResolve = null;
        const qsFullscreenState = {
            container: null,
            modals: []
        };

        function getFullscreenElement() {
            return document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.msFullscreenElement ||
                null;
        }

        function getRequestFullscreenFn(element) {
            if (!element) {
                return null;
            }
            return element.requestFullscreen ||
                element.webkitRequestFullscreen ||
                element.msRequestFullscreen ||
                null;
        }

        function trackModalElement(id, fullscreenSelector = null) {
            const el = document.getElementById(id);
            if (!el) {
                return;
            }

            const alreadyTracked = qsFullscreenState.modals.some(item => item.el === el);
            if (alreadyTracked) {
                return;
            }

            qsFullscreenState.modals.push({
                el,
                parent: el.parentNode,
                nextSibling: el.nextSibling,
                fullscreenSelector
            });
        }

        function moveModalsToContainer(container) {
            if (!container) {
                return;
            }
            qsFullscreenState.modals.forEach(item => {
                const { el, fullscreenSelector } = item;
                if (!el) {
                    return;
                }
                const target = fullscreenSelector
                    ? container.querySelector(fullscreenSelector) || container
                    : container;
                if (target && el.parentNode !== target) {
                    target.appendChild(el);
                }
            });
        }

        function restoreModalsToOriginal() {
            qsFullscreenState.modals.forEach(item => {
                const { el, parent, nextSibling } = item;
                if (!el || !parent) {
                    return;
                }

                if (nextSibling && nextSibling.parentNode === parent) {
                    parent.insertBefore(el, nextSibling);
                } else {
                    parent.appendChild(el);
                }
            });
        }

        function handleFullscreenChange() {
            const current = getFullscreenElement();
            const container = qsFullscreenState.container || document.querySelector('.video-section');
            qsFullscreenState.container = container;

            if (videoElement && current === videoElement && container && container !== videoElement) {
                const request = getRequestFullscreenFn(container);
                if (typeof request === 'function') {
                    request.call(container);
                }
                return;
            }

            const isContainerFullscreen = current && container && current === container;

            document.body.classList.toggle('qs-fullscreen', Boolean(isContainerFullscreen));

            if (container) {
                container.classList.toggle('qs-fullscreen-active', Boolean(isContainerFullscreen));
            }

            if (videoElement) {
                videoElement.classList.toggle('qs-fullscreen-video', Boolean(isContainerFullscreen));
            }

            if (isContainerFullscreen) {
                moveModalsToContainer(container);
            } else {
                restoreModalsToOriginal();
            }
        }

        function initFullscreenSupport() {
            qsFullscreenState.container = document.querySelector('.video-section');
            trackModalElement('pause-overlay', '.video-container');
            trackModalElement('add-question-modal');
            trackModalElement('llm-review-modal');

            ['fullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange'].forEach(eventName => {
                document.addEventListener(eventName, handleFullscreenChange);
            });

            handleFullscreenChange();
        }


        function acquireModalPlaybackLock() {
            if (!videoElement) {
                return;
            }

            if (modalPlaybackLockCount === 0) {
                modalPlaybackWasPlaying = !videoElement.paused;
            }

            modalPlaybackLockCount += 1;
            videoElement.pause();
        }

        function releaseModalPlaybackLock(options = {}) {
            const resume = options && typeof options.resume === 'boolean' ? options.resume : false;

            if (!videoElement) {
                modalPlaybackLockCount = Math.max(0, modalPlaybackLockCount - 1);
                modalPlaybackWasPlaying = false;
                return;
            }

            if (modalPlaybackLockCount > 0) {
                modalPlaybackLockCount -= 1;
            }

            if (modalPlaybackLockCount === 0) {
                if (resume && modalPlaybackWasPlaying) {
                    videoElement.play();
                }
                modalPlaybackWasPlaying = false;
            }
        }

        function isVideoPlaybackLocked() {
            return modalPlaybackLockCount > 0;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initFullscreenSupport();
            initStepNavigation();
            loadVideoList();
            resetReviewPanel();
            updateReviewButtonState();

            const expertForm = document.getElementById('expert-question-form');
            if (expertForm) {
                expertForm.addEventListener('submit', handleExpertQuestionSubmit);
            }

            const skipButton = document.getElementById('expert-skip-button');
            if (skipButton) {
                skipButton.addEventListener('click', handleExpertSkip);
            }
            
            // Manual question form handler
            const manualForm = document.getElementById('manual-question-form');
            if (manualForm) {
                manualForm.addEventListener('submit', handleManualQuestionSubmit);
            }

            const llmNextButton = document.getElementById('llm-step-next-btn');
            if (llmNextButton) {
                llmNextButton.addEventListener('click', handleLLMStepNext);
            }

            const llmNextReviewButton = document.getElementById('llm-step-next-review-btn');
            if (llmNextReviewButton) {
                llmNextReviewButton.addEventListener('click', handleLLMStepNext);
            }

            const llmBackButton = document.getElementById('llm-step-back-btn');
            if (llmBackButton) {
                llmBackButton.addEventListener('click', handleLLMStepBack);
            }

            const llmEditBackButton = document.getElementById('llm-step-edit-back-btn');
            if (llmEditBackButton) {
                llmEditBackButton.addEventListener('click', handleLLMStepBack);
            }

            const llmSubmitButton = document.getElementById('llm-review-submit-btn');
            if (llmSubmitButton) {
                llmSubmitButton.addEventListener('click', handleLLMModalSubmit);
            }

            const llmTriageCommentInput = document.getElementById('llm-triage-comment');
            if (llmTriageCommentInput) {
                llmTriageCommentInput.addEventListener('input', () => {
                    llmModalState.triageComment = llmTriageCommentInput.value;
                });
            }

            const llmRankingCommentInput = document.getElementById('llm-ranking-comment');
            if (llmRankingCommentInput) {
                llmRankingCommentInput.addEventListener('input', () => {
                    llmModalState.rankingComment = llmRankingCommentInput.value;
                });
            }
        });
        
        function initStepNavigation() {
            const stepElements = document.querySelectorAll('.step');
            stepElements.forEach(stepEl => {
                stepEl.addEventListener('click', () => {
                    const targetStep = Number(stepEl.dataset.step);
                    if (targetStep <= maxAvailableStep) {
                        showStep(targetStep);
                    }
                });
            });
            updateStepAccess();
            showStep(currentStep);
        }

        function updateStepAccess() {
            document.querySelectorAll('.step').forEach(stepEl => {
                const stepNumber = Number(stepEl.dataset.step);
                stepEl.classList.toggle('step-disabled', stepNumber > maxAvailableStep);
            });
        }

        function showStep(step) {
            // Pause video if leaving step 2
            if (currentStep === 2 && step !== 2 && videoElement) {
                videoElement.pause();
            }
            
            currentStep = step;
            document.querySelectorAll('.step').forEach(stepEl => {
                const stepNumber = Number(stepEl.dataset.step);
                stepEl.classList.toggle('active', stepNumber === step);
                stepEl.classList.toggle('completed', stepNumber < step);
            });
            document.querySelectorAll('.step-content').forEach(contentEl => {
                const stepNumber = Number(contentEl.dataset.step);
                contentEl.classList.toggle('active', stepNumber === step);
            });
            
            // Resume video if returning to step 2 and it was playing before
            if (step === 2 && videoElement && !isVideoPaused) {
                // Only resume if we're not in a pause overlay
                const pauseOverlay = document.getElementById('pause-overlay');
                if (!pauseOverlay || !pauseOverlay.classList.contains('active')) {
                    videoElement.play();
                }
            }
        }

        function unlockStep(step) {
            if (step > maxAvailableStep) {
                maxAvailableStep = step;
            }
            updateStepAccess();
            showStep(step);
        }

        function findVideoById(videoId) {
            if (!videoId) {
                return null;
            }
            return availableVideos.find(video => video.id === videoId) || null;
        }

        function renderVideoList() {
            const list = document.getElementById('video-card-list');
            if (!list) {
                return;
            }

            list.innerHTML = '';

            if (!availableVideos.length) {
                list.innerHTML = '<div class="video-list-empty">No downloaded videos found yet.</div>';
                return;
            }

            availableVideos.forEach(video => {
                const card = document.createElement('button');
                card.type = 'button';
                card.className = 'video-card';
                card.dataset.videoId = video.id;

                if (video.id === currentVideoId) {
                    card.classList.add('selected');
                }

                const durationText = video.duration ? formatDuration(video.duration) : '0:00';
                const baseLabel = video.title || video.id;
                const subtitle = video.id;
                const fileCount = typeof video.fileCount === 'number' ? video.fileCount : 0;
                const questionCount = typeof video.questionCount === 'number' ? video.questionCount : null;
                const questionText = questionCount !== null ? `Questions: ${questionCount}` : 'Questions: N/A';
                const rawThumbnail = typeof video.thumbnail === 'string' ? video.thumbnail.trim() : '';
                const thumbnailUrl = rawThumbnail;
                const hasThumbnail = thumbnailUrl.length > 0;
                const placeholderInitial = baseLabel ? baseLabel.trim().charAt(0).toUpperCase() : 'V';
                const showDurationBadge = durationText && durationText !== '0:00';

                card.innerHTML = `
                    <div class="video-card-thumb">
                        ${hasThumbnail
                            ? `<img class="video-card-thumb-image" src="${thumbnailUrl}" alt="${baseLabel}">`
                            : `<div class="video-card-thumb-placeholder">${placeholderInitial}</div>`}
                        ${showDurationBadge ? `<span class="video-card-duration-badge">${durationText}</span>` : ''}
                    </div>
                    <div class="video-card-details">
                        <div class="video-card-title">${baseLabel}</div>
                        <div class="video-card-subtitle">${subtitle}</div>
                        <div class="video-card-meta">
                            <span>Duration: ${durationText}</span>
                            <span>Files: ${fileCount}</span>
                            <span>${questionText}</span>
                        </div>
                    </div>
                `;

                card.addEventListener('click', () => handleVideoSelection(video.id));
                card.classList.remove('loading');
                list.appendChild(card);
            });

            if (currentVideoId) {
                setVideoCardState(currentVideoId, 'selected');
            }
        }

        function setVideoCardState(videoId, state) {
            const cards = document.querySelectorAll('.video-card');
            cards.forEach(card => {
                const isTarget = card.dataset.videoId === videoId;

                if (state === 'loading') {
                    card.classList.remove('selected');
                    if (isTarget) {
                        card.classList.add('loading');
                        card.disabled = true;
                    } else {
                        card.classList.remove('loading');
                        card.disabled = false;
                    }
                } else if (state === 'selected') {
                    card.classList.remove('loading');
                    card.disabled = false;
                    card.classList.toggle('selected', isTarget);
                } else if (state === 'idle') {
                    card.classList.remove('loading');
                    card.disabled = false;
                    if (isTarget) {
                        card.classList.remove('selected');
                    }
                }
            });
        }

        function normalizeSegmentValue(value) {
            const num = Number(value);
            if (Number.isNaN(num)) {
                return 0;
            }
            return Number(num.toFixed(3));
        }

        function normalizeQuestionType(value) {
            if (!value) {
                return '';
            }
            return String(value).toLowerCase();
        }

        function getExpertQuestionTypeLabel(value) {
            const labels = {
                character: 'Character',
                setting: 'Setting',
                feeling: 'Feeling',
                action: 'Action',
                causal: 'Causal',
                outcome: 'Outcome',
                prediction: 'Prediction'
            };

            const normalized = normalizeQuestionType(value);
            return labels[normalized] || (value ? String(value) : 'Unknown');
        }

        function getSegmentKey(segment) {
            if (!segment) {
                return '';
            }
            const start = normalizeSegmentValue(segment.start);
            const end = normalizeSegmentValue(segment.end);
            return `${start}-${end}`;
        }

        function getExpertQuestionForSegment(segment) {
            const key = getSegmentKey(segment);
            if (!key) {
                return null;
            }
            return expertQuestions[key] || null;
        }

        function setExpertQuestionForSegment(segment, data) {
            const key = getSegmentKey(segment);
            if (!key) {
                return;
            }

            if (!data) {
                delete expertQuestions[key];
                return;
            }

            const normalized = { ...data };

            if (normalized.skip_reason && !normalized.skipReason) {
                normalized.skipReason = normalized.skip_reason;
            }
            delete normalized.skip_reason;

            if (!normalized.updatedAt && normalized.updated_at) {
                normalized.updatedAt = normalized.updated_at;
            }
            delete normalized.updated_at;

            normalized.skipped = Boolean(normalized.skipped);

            if (normalized.skipped) {
                normalized.questionType = '';
                normalized.question = normalized.question || '';
                normalized.answer = normalized.answer || '';
                normalized.skipReason = normalized.skipReason ? String(normalized.skipReason) : '';
            } else {
                const typeValue = normalized.questionType || normalized.question_type || '';
                normalized.questionType = normalizeQuestionType(typeValue);
                normalized.skipReason = '';
            }

            delete normalized.question_type;

            expertQuestions[key] = normalized;
        }

        function hasExpertDecision(segment) {
            const entry = getExpertQuestionForSegment(segment);
            if (!entry) {
                return false;
            }

            if (entry.skipped) {
                return true;
            }

            return Boolean(entry.question && entry.answer);
        }

        function renderExpertInfoMessage(container, message) {
            if (!container) {
                return;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'question-item';

            const textEl = document.createElement('div');
            textEl.className = 'question-text';
            textEl.style.textAlign = 'center';
            textEl.style.color = '#718096';
            textEl.textContent = message;

            wrapper.appendChild(textEl);
            container.appendChild(wrapper);
        }

        function updateExpertQuestionsPanel(segment = null) {
            const container = document.getElementById('expert-questions');
            if (!container) {
                return;
            }

            container.innerHTML = '';

            // Show all saved expert questions
            if (currentSegments && currentSegments.length > 0) {
                let hasAnyQuestions = false;
                
                // First, show questions for defined segments
                currentSegments.forEach((seg, index) => {
                    const entry = getExpertQuestionForSegment(seg);
                    if (entry) {
                        hasAnyQuestions = true;
                        
                        const questionDiv = document.createElement('div');
                        questionDiv.className = 'question-item';
                        
                        // Add highlight if this is the current segment
                        if (segment && seg === segment) {
                            questionDiv.style.border = '2px solid #3182ce';
                            questionDiv.style.backgroundColor = '#ebf8ff';
                        }
                        
                        // Add segment header
                        const segmentHeader = document.createElement('div');
                        segmentHeader.style.fontSize = '0.85rem';
                        segmentHeader.style.color = '#718096';
                        segmentHeader.style.marginBottom = '8px';
                        segmentHeader.textContent = `Segment ${index + 1} (${formatTime(seg.start)} - ${formatTime(seg.end)})`;
                        questionDiv.appendChild(segmentHeader);

                        if (entry.skipped) {
                            questionDiv.classList.add('skipped');

                            const badge = document.createElement('div');
                            badge.className = 'question-type-badge';
                            badge.textContent = 'Skipped';
                            questionDiv.appendChild(badge);

                            const messageEl = document.createElement('div');
                            messageEl.className = 'question-text';
                            messageEl.textContent = 'Segment marked as skipped';
                            questionDiv.appendChild(messageEl);

                            if (entry.skipReason) {
                                const reasonEl = document.createElement('div');
                                reasonEl.className = 'answer-text';
                                reasonEl.textContent = `Reason: ${entry.skipReason}`;
                                questionDiv.appendChild(reasonEl);
                            }
                        } else {
                            const badge = document.createElement('div');
                            badge.className = 'question-type-badge';
                            badge.textContent = getExpertQuestionTypeLabel(entry.questionType);
                            questionDiv.appendChild(badge);

                            const questionText = document.createElement('div');
                            questionText.className = 'question-text';
                            questionText.textContent = entry.question || '';
                            questionDiv.appendChild(questionText);

                            const answerText = document.createElement('div');
                            answerText.className = 'answer-text';
                            answerText.textContent = entry.answer || '';
                            questionDiv.appendChild(answerText);
                        }

                        container.appendChild(questionDiv);
                    }
                });
                
                // Also show manually added questions
                Object.entries(expertQuestions).forEach(([key, entry]) => {
                    if (entry && entry.isManual) {
                        hasAnyQuestions = true;
                        
                        const questionDiv = document.createElement('div');
                        questionDiv.className = 'question-item';
                        questionDiv.style.borderLeft = '4px solid #38a169';
                        
                        // Add manual question header
                        const segmentHeader = document.createElement('div');
                        segmentHeader.style.fontSize = '0.85rem';
                        segmentHeader.style.color = '#38a169';
                        segmentHeader.style.marginBottom = '8px';
                        segmentHeader.textContent = `Manual Question @ ${formatTime(entry.timestamp || 0)}`;
                        questionDiv.appendChild(segmentHeader);
                        
                        const badge = document.createElement('div');
                        badge.className = 'question-type-badge';
                        badge.style.background = '#38a169';
                        badge.textContent = getExpertQuestionTypeLabel(entry.questionType);
                        questionDiv.appendChild(badge);

                        const questionText = document.createElement('div');
                        questionText.className = 'question-text';
                        questionText.textContent = entry.question || '';
                        questionDiv.appendChild(questionText);

                        const answerText = document.createElement('div');
                        answerText.className = 'answer-text';
                        answerText.textContent = entry.answer || '';
                        questionDiv.appendChild(answerText);
                        
                        container.appendChild(questionDiv);
                    }
                });
                
                if (!hasAnyQuestions) {
                    renderExpertInfoMessage(container, 'No expert questions saved yet. Play the video to add questions at each segment or use "Add Question" button.');
                }
            } else {
                renderExpertInfoMessage(container, 'Select a video to begin adding expert questions.');
            }
        }

        function findNextIncompleteSegmentIndex(startIndex = 0) {
            if (!currentSegments || currentSegments.length === 0) {
                return 0;
            }

            for (let index = Math.max(0, startIndex); index < currentSegments.length; index++) {
                if (!hasExpertDecision(currentSegments[index])) {
                    return index;
                }
            }

            return currentSegments.length;
        }

        function setExpertFormFeedback(message, type = 'error') {
            const feedback = document.getElementById('expert-form-feedback');
            if (!feedback) {
                return;
            }

            feedback.textContent = message || '';
            feedback.classList.remove('success');

            if (message && type === 'success') {
                feedback.classList.add('success');
            }
        }

        function toggleExpertFormState(disabled) {
            const form = document.getElementById('expert-question-form');
            if (!form) {
                return;
            }

            Array.from(form.elements).forEach(element => {
                if (!element) {
                    return;
                }

                if (element.id === 'expert-skip-button') {
                    element.disabled = disabled;
                    return;
                }

                element.disabled = disabled;
            });
        }

        function resetExpertForm() {
            const form = document.getElementById('expert-question-form');
            if (form) {
                form.reset();
            }

            setExpertFormFeedback('');
            expertSaveInProgress = false;
            toggleExpertFormState(false);
        }

        function populateExpertForm(segment) {
            const typeSelect = document.getElementById('expert-question-type');
            const questionInput = document.getElementById('expert-question-text');
            const answerInput = document.getElementById('expert-answer-text');

            const existing = getExpertQuestionForSegment(segment);

            if (existing) {
                if (existing.skipped) {
                    if (typeSelect) {
                        typeSelect.value = '';
                    }
                    if (questionInput) {
                        questionInput.value = '';
                    }
                    if (answerInput) {
                        answerInput.value = '';
                    }
                    setExpertFormFeedback('This segment is marked as skipped. Add a question to replace it or skip again.');
                } else {
                    if (typeSelect) {
                        typeSelect.value = normalizeQuestionType(existing.questionType);
                    }
                    if (questionInput) {
                        questionInput.value = existing.question || '';
                    }
                    if (answerInput) {
                        answerInput.value = existing.answer || '';
                    }
                    setExpertFormFeedback('Existing question loaded for this segment.', 'success');
                }
            } else {
                if (typeSelect) {
                    typeSelect.value = '';
                }
                if (questionInput) {
                    questionInput.value = '';
                }
                if (answerInput) {
                    answerInput.value = '';
                }
                setExpertFormFeedback('');
            }

            expertSaveInProgress = false;
            toggleExpertFormState(false);
        }

        async function handleVideoSelection(videoId) {
            if (!videoId || isLoadingVideo) {
                return;
            }

            const video = findVideoById(videoId);
            if (!video) {
                return;
            }

            await loadVideo(video.id, video.title);
        }

        async function handleExpertQuestionSubmit(event) {
            event.preventDefault();

            if (expertSaveInProgress) {
                return;
            }

            if (!currentVideoId) {
                setExpertFormFeedback('Select a video before saving questions.');
                return;
            }

            const segment = currentSegments[currentSegmentIndex];
            if (!segment) {
                setExpertFormFeedback('No segment selected.');
                return;
            }

            const typeSelect = document.getElementById('expert-question-type');
            const questionInput = document.getElementById('expert-question-text');
            const answerInput = document.getElementById('expert-answer-text');

            const questionType = normalizeQuestionType(typeSelect ? typeSelect.value.trim() : '');
            const question = questionInput ? questionInput.value.trim() : '';
            const answer = answerInput ? answerInput.value.trim() : '';

            // Strict validation - all fields must be filled
            if (!questionType || questionType === '') {
                setExpertFormFeedback('Please select a question type.');
                typeSelect.focus();
                return;
            }

            if (getExpertQuestionTypeLabel(questionType) === 'Unknown') {
                setExpertFormFeedback('Please select a valid question type.');
                typeSelect.focus();
                return;
            }

            if (!question || question === '') {
                setExpertFormFeedback('Please enter a question. This field is required.');
                questionInput.focus();
                return;
            }

            if (!answer || answer === '') {
                setExpertFormFeedback('Please enter an answer. This field is required.');
                answerInput.focus();
                return;
            }

            expertSaveInProgress = true;
            toggleExpertFormState(true);
            setExpertFormFeedback('Saving question...', 'success');

            const payload = {
                videoId: currentVideoId,
                segmentStart: segment.start,
                segmentEnd: segment.end,
                timestamp: segment.end,
                questionType,
                question,
                answer
            };

            try {
                const response = await fetch('/api/expert-questions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok || !data.success) {
                    const errorMessage = data && data.message ? data.message : 'Failed to save question.';
                    throw new Error(errorMessage);
                }

                setExpertQuestionForSegment(segment, {
                    videoId: currentVideoId,
                    segmentStart: segment.start,
                    segmentEnd: segment.end,
                    timestamp: segment.end,
                    questionType,
                    question,
                    answer,
                    skipReason: '',
                    updatedAt: data.updatedAt || new Date().toISOString()
                });

                updateExpertQuestionsPanel(segment);
                await showLLMReviewForSegment(segment, currentSegmentIndex);
            } catch (error) {
                console.error('Failed to save expert question:', error);
                setExpertFormFeedback(error.message || 'Failed to save question.');
            } finally {
                expertSaveInProgress = false;
                toggleExpertFormState(false);
            }
        }

        async function handleExpertSkip(event) {
            if (event) {
                event.preventDefault();
            }

            if (expertSaveInProgress) {
                return;
            }

            if (!currentVideoId) {
                setExpertFormFeedback('Select a video before skipping segments.');
                return;
            }

            const segment = currentSegments[currentSegmentIndex];
            if (!segment) {
                setExpertFormFeedback('No segment selected.');
                return;
            }

            expertSaveInProgress = true;
            toggleExpertFormState(true);
            setExpertFormFeedback('Marking segment as skipped...', 'success');

            const payload = {
                videoId: currentVideoId,
                segmentStart: segment.start,
                segmentEnd: segment.end,
                timestamp: segment.end,
                skipped: true
            };

            try {
                const response = await fetch('/api/expert-questions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok || !data.success) {
                    const errorMessage = data && data.message ? data.message : 'Failed to skip segment.';
                    throw new Error(errorMessage);
                }

                const record = {
                    videoId: currentVideoId,
                    segmentStart: segment.start,
                    segmentEnd: segment.end,
                    timestamp: segment.end,
                    skipped: true,
                    skipReason: '',
                    updatedAt: data.updatedAt || new Date().toISOString()
                };

                setExpertQuestionForSegment(segment, record);
                updateExpertQuestionsPanel(segment);
                await showLLMReviewForSegment(segment, currentSegmentIndex);
            } catch (error) {
                console.error('Failed to skip segment:', error);
                setExpertFormFeedback(error.message || 'Failed to skip segment.');
            } finally {
                expertSaveInProgress = false;
                toggleExpertFormState(false);
            }
        }



        async function showLLMReviewForSegment(segment, segmentIndex) {
            llmModalResolve = null;

            if (!segment || !currentVideoId) {

                hidePauseOverlay();

                releaseModalPlaybackLock({ resume: false });

                approveAndContinue();

                if (typeof llmModalResolve === 'function') {

                    llmModalResolve();

                    llmModalResolve = null;

                }

                return;

            }



            const questions = await resolveSegmentQuestions(segment);



            if (!questions || Object.keys(questions).length === 0) {

                hidePauseOverlay();

                releaseModalPlaybackLock({ resume: false });

                approveAndContinue();

                if (typeof llmModalResolve === 'function') {

                    llmModalResolve();

                    llmModalResolve = null;

                }

                return;

            }



            const segmentKey = getSegmentKey(segment);



            if (!llmQuestionEdits[currentVideoId]) {

                llmQuestionEdits[currentVideoId] = {};

            }



            const entries = [];

            Object.entries(questions).forEach(([type, data]) => {

                const questionKey = `${segmentKey}_${type}`;

                const edits = llmQuestionEdits[currentVideoId][questionKey] || {};



                entries.push({

                    questionKey,

                    type,

                    originalQuestion: data.q || '',

                    originalAnswer: data.a || '',

                    question: edits.question !== undefined ? edits.question : (data.q || ''),

                    answer: edits.answer !== undefined ? edits.answer : (data.a || ''),

                    trashed: Boolean(edits.trashed),

                    modified: Boolean(edits.modified),

                    timestamp: edits.timestamp || null

                });

            });



            if (!entries.length) {

                hidePauseOverlay();

                releaseModalPlaybackLock({ resume: false });

                approveAndContinue();

                if (typeof llmModalResolve === 'function') {

                    llmModalResolve();

                    llmModalResolve = null;

                }

                return;

            }



            const rankingInfo = llmQuestionEdits[currentVideoId][`${segmentKey}_ranking`] || {};

            const validKeys = entries.map(entry => entry.questionKey);



            const rankingOrder = Array.isArray(rankingInfo.order)

                ? rankingInfo.order.filter(key => {

                    if (!validKeys.includes(key)) {

                        return false;

                    }

                    const entry = entries.find(item => item.questionKey === key);

                    return entry ? !entry.trashed : true;

                })

                : [];



            entries.forEach(entry => {

                if (!entry.trashed && !rankingOrder.includes(entry.questionKey)) {

                    rankingOrder.push(entry.questionKey);

                }

            });



            const trashOrder = [];

            if (Array.isArray(rankingInfo.trashed)) {

                rankingInfo.trashed.forEach(key => {

                    if (validKeys.includes(key) && !trashOrder.includes(key)) {

                        trashOrder.push(key);

                    }

                });

            }

            entries.forEach(entry => {

                if (entry.trashed && !trashOrder.includes(entry.questionKey)) {

                    trashOrder.push(entry.questionKey);

                }

            });



            llmModalState.open = true;

            llmModalState.segmentKey = segmentKey;

            llmModalState.segmentIndex = segmentIndex;

            llmModalState.questions = entries;

            llmModalState.rankingOrder = rankingOrder;

            llmModalState.trashOrder = trashOrder;

            llmModalState.openQuestionKey = rankingOrder[0] || trashOrder[0] || null;

            llmModalState.draggingKey = null;

            llmModalState.dragSource = null;

            llmModalState.step = 1;

            llmModalState.editingKey = null;

            llmModalState.triageComment = typeof rankingInfo.triageComment === 'string' ? rankingInfo.triageComment : '';

            const savedRankingComment = typeof rankingInfo.rankingComment === 'string'

                ? rankingInfo.rankingComment

                : (typeof rankingInfo.comment === 'string' ? rankingInfo.comment : '');

            llmModalState.rankingComment = savedRankingComment;



            const segmentLabel = document.getElementById('llm-modal-segment-label');

            if (segmentLabel) {

                segmentLabel.textContent = `Segment ${segmentIndex + 1} (${formatTime(segment.start)} - ${formatTime(segment.end)})`;

            }



            const triageCommentInput = document.getElementById('llm-triage-comment');

            if (triageCommentInput) {

                triageCommentInput.value = llmModalState.triageComment || '';

            }



            const rankingCommentInput = document.getElementById('llm-ranking-comment');

            if (rankingCommentInput) {

                rankingCommentInput.value = llmModalState.rankingComment || '';

            }



            const feedback = document.getElementById('llm-modal-feedback');

            if (feedback) {

                feedback.textContent = '';

            }



            hidePauseOverlay();

            acquireModalPlaybackLock();

            setLLMStep(1);



            const modal = document.getElementById('llm-review-modal');

            if (modal) {

                modal.classList.add('active');

            }



            return new Promise(resolve => {

                llmModalResolve = resolve;

            });

        }



        function clearLLMModalState() {

            llmModalState.open = false;

            llmModalState.segmentKey = null;

            llmModalState.segmentIndex = null;

            llmModalState.questions = [];

            llmModalState.rankingOrder = [];

            llmModalState.trashOrder = [];

            llmModalState.openQuestionKey = null;

            llmModalState.draggingKey = null;

            llmModalState.dragSource = null;

            llmModalState.step = 1;

            llmModalState.editingKey = null;

            llmModalState.triageComment = '';

            llmModalState.rankingComment = '';

        }



        function closeLLMReviewModal() {

            const modal = document.getElementById('llm-review-modal');

            if (modal) {

                modal.classList.remove('active');

            }



            const triageCommentInput = document.getElementById('llm-triage-comment');

            if (triageCommentInput) {

                triageCommentInput.value = '';

            }



            const rankingCommentInput = document.getElementById('llm-ranking-comment');

            if (rankingCommentInput) {

                rankingCommentInput.value = '';

            }



            const feedback = document.getElementById('llm-modal-feedback');

            if (feedback) {

                feedback.textContent = '';

            }



            const dropzone = document.getElementById('llm-trash-dropzone');

            if (dropzone) {

                dropzone.classList.remove('drag-over');

            }



            clearLLMModalState();

        }



        function setLLMStep(step) {

            llmModalState.step = step;

            llmModalState.editingKey = null;



            const title = document.getElementById('llm-modal-step-title');

            if (title) {

                const titles = {

                    1: 'Review AI Questions',

                    2: 'Review AI Questions',

                    3: 'Review AI Questions'

                };

                title.textContent = titles[step] || 'Review AI Questions';

            }



            document.querySelectorAll('.llm-step-content').forEach(content => {

                content.classList.toggle('active', content.id === `llm-step-${step}`);

            });



            if (step === 1) {

                renderLLMStepOne();

                const triageCommentInput = document.getElementById('llm-triage-comment');

                if (triageCommentInput) {

                    triageCommentInput.value = llmModalState.triageComment || '';

                }

            } else if (step === 2) {

                renderLLMStepTwo();

                const rankingCommentInput = document.getElementById('llm-ranking-comment');

                if (rankingCommentInput) {

                    rankingCommentInput.value = llmModalState.rankingComment || '';

                }

            } else if (step === 3) {

                const combinedOrder = getCombinedLLMOrder();

                if (!combinedOrder.includes(llmModalState.openQuestionKey)) {

                    llmModalState.openQuestionKey = combinedOrder[0] || null;

                }

                renderLLMAccordion();

            }

        }



        function renderLLMStepOne() {

            const triageList = document.getElementById('llm-triage-list');

            const triageEmpty = document.getElementById('llm-triage-empty');

            const trashList = document.getElementById('llm-triage-trash-list');

            const trashEmpty = document.getElementById('llm-triage-trash-empty');



            if (!triageList || !trashList) {

                return;

            }



            triageList.innerHTML = '';

            trashList.innerHTML = '';



            const activeKeys = llmModalState.rankingOrder || [];

            const trashKeys = llmModalState.trashOrder || [];



            activeKeys.forEach((key, index) => {

                const item = createLLMTriageItem(key, index);

                if (item) {

                    triageList.appendChild(item);

                }

            });



            trashKeys.forEach((key, index) => {

                const item = createLLMListItem(key, index, 'trash');

                if (item) {

                    trashList.appendChild(item);

                }

            });



            if (triageEmpty) {

                triageEmpty.style.display = activeKeys.length ? 'none' : 'block';

            }



            if (trashEmpty) {

                trashEmpty.style.display = trashKeys.length ? 'none' : 'block';

            }

        }



        function createLLMTriageItem(questionKey, index) {

            const entry = getLLMEntry(questionKey);

            if (!entry || entry.trashed) {

                return null;

            }



            const item = document.createElement('li');

            item.className = 'llm-triage-item';

            item.dataset.questionKey = questionKey;

            item.dataset.index = String(index);



            const textWrapper = document.createElement('div');

            textWrapper.className = 'llm-item-text';



            const typeEl = document.createElement('div');

            typeEl.className = 'llm-item-type';

            typeEl.textContent = entry.type;

            textWrapper.appendChild(typeEl);



            const questionEl = document.createElement('div');

            questionEl.className = 'llm-item-question';

            questionEl.textContent = entry.question || '(empty question)';

            textWrapper.appendChild(questionEl);



            item.appendChild(textWrapper);



            const actions = document.createElement('div');

            actions.className = 'llm-triage-actions';



            const trashButton = document.createElement('button');

            trashButton.type = 'button';

            trashButton.className = 'btn btn-danger btn-sm';

            trashButton.textContent = 'Trash';

            trashButton.addEventListener('click', () => moveLLMQuestionToTrash(questionKey));

            actions.appendChild(trashButton);



            item.appendChild(actions);



            return item;

        }



        function attachLLMListListeners() {

            const rankingList = document.getElementById('llm-ranking-list');

            const trashDropzone = document.getElementById('llm-trash-dropzone');

            const trashList = document.getElementById('llm-ranking-trash-list');



            if (rankingList && rankingList.dataset.listenersAttached !== 'true') {

                rankingList.addEventListener('dragover', handleLLMRankingDragOver);

                rankingList.addEventListener('drop', handleLLMRankingDrop);

                rankingList.dataset.listenersAttached = 'true';

            }



            if (trashDropzone && trashDropzone.dataset.listenersAttached !== 'true') {

                trashDropzone.addEventListener('dragover', handleLLMTrashDragOver);

                trashDropzone.addEventListener('dragleave', handleLLMTrashDragLeave);

                trashDropzone.addEventListener('drop', handleLLMTrashDrop);

                trashDropzone.dataset.listenersAttached = 'true';

            }



            if (trashList && trashList.dataset.listenersAttached !== 'true') {

                trashList.addEventListener('dragover', handleLLMTrashDragOver);

                trashList.addEventListener('dragleave', handleLLMTrashDragLeave);

                trashList.addEventListener('drop', handleLLMTrashDrop);

                trashList.dataset.listenersAttached = 'true';

            }

        }



        function createLLMListItem(questionKey, index, listType) {

            const entry = getLLMEntry(questionKey);

            if (!entry) {

                return null;

            }



            const item = document.createElement('li');

            item.className = listType === 'ranking' ? 'llm-ranking-item' : 'llm-trash-item';

            item.dataset.questionKey = questionKey;

            item.dataset.list = listType;

            item.draggable = listType === 'ranking';

            if (item.draggable) {

                item.addEventListener('dragstart', handleLLMDragStart);

                item.addEventListener('dragend', handleLLMDragEnd);

            }



            if (listType === 'ranking') {

                const badge = document.createElement('span');

                badge.className = 'llm-rank-badge';

                badge.textContent = String(index + 1);

                item.appendChild(badge);

            }



            const textWrapper = document.createElement('div');

            textWrapper.className = 'llm-item-text';



            const typeEl = document.createElement('div');

            typeEl.className = 'llm-item-type';

            typeEl.textContent = entry.type;

            textWrapper.appendChild(typeEl);



            const questionEl = document.createElement('div');

            questionEl.className = 'llm-item-question';

            questionEl.textContent = entry.question || '(empty question)';

            textWrapper.appendChild(questionEl);



            item.appendChild(textWrapper);



            if (listType === 'trash') {

                const restoreButton = document.createElement('button');

                restoreButton.type = 'button';

                restoreButton.className = 'btn btn-light btn-sm';

                restoreButton.textContent = 'Restore';

                restoreButton.addEventListener('click', () => moveLLMQuestionToRanking(questionKey));

                item.appendChild(restoreButton);

            }



            return item;

        }



        function handleLLMDragStart(event) {

            const key = event.currentTarget && event.currentTarget.dataset ? event.currentTarget.dataset.questionKey : null;

            if (!key) {

                return;

            }



            llmModalState.draggingKey = key;

            const parentList = event.currentTarget.closest('.llm-trash-list');

            llmModalState.dragSource = parentList ? 'trash' : 'ranking';

            if (event.dataTransfer) {

                event.dataTransfer.effectAllowed = 'move';

                event.dataTransfer.setData('text/plain', key);

            }



            event.currentTarget.classList.add('dragging');

        }



        function handleLLMDragEnd(event) {

            if (event.currentTarget) {

                event.currentTarget.classList.remove('dragging');

            }

            llmModalState.draggingKey = null;

            llmModalState.dragSource = null;

        }



        function handleLLMRankingDragOver(event) {

            event.preventDefault();

        }



        function handleLLMRankingDrop(event) {

            event.preventDefault();

            const draggedKey = llmModalState.draggingKey || (event.dataTransfer && event.dataTransfer.getData('text/plain'));

            if (!draggedKey) {

                return;

            }



            const list = document.getElementById('llm-ranking-list');

            const index = getLLMDropIndex(list, event.clientY);

            moveLLMQuestionToRanking(draggedKey, index);

            llmModalState.draggingKey = null;

            llmModalState.dragSource = null;

        }



        function handleLLMTrashDragOver(event) {

            event.preventDefault();

            const dropzone = document.getElementById('llm-trash-dropzone');

            if (dropzone) {

                dropzone.classList.add('drag-over');

            }

        }



        function handleLLMTrashDragLeave() {

            const dropzone = document.getElementById('llm-trash-dropzone');

            if (dropzone) {

                dropzone.classList.remove('drag-over');

            }

        }



        function handleLLMTrashDrop(event) {

            event.preventDefault();

            const draggedKey = llmModalState.draggingKey || (event.dataTransfer && event.dataTransfer.getData('text/plain'));

            if (!draggedKey) {

                return;

            }



            moveLLMQuestionToTrash(draggedKey);

            llmModalState.draggingKey = null;

            llmModalState.dragSource = null;

            const dropzone = document.getElementById('llm-trash-dropzone');

            if (dropzone) {

                dropzone.classList.remove('drag-over');

            }

        }



        function getLLMDropIndex(list, clientY) {

            if (!list) {

                return 0;

            }



            const items = Array.from(list.querySelectorAll('li')).filter(item => !item.classList.contains('dragging'));

            for (let index = 0; index < items.length; index++) {

                const rect = items[index].getBoundingClientRect();

                if (clientY < rect.top + rect.height / 2) {

                    return index;

                }

            }

            return items.length;

        }



        function moveLLMQuestionToRanking(questionKey, position) {

            if (!questionKey) {

                return;

            }



            const validKeys = llmModalState.questions.map(entry => entry.questionKey);

            if (!validKeys.includes(questionKey)) {

                return;

            }



            llmModalState.trashOrder = (llmModalState.trashOrder || []).filter(key => key !== questionKey);

            let order = (llmModalState.rankingOrder || []).filter(key => key !== questionKey);



            if (typeof position === 'number' && position >= 0 && position <= order.length) {

                order.splice(position, 0, questionKey);

            } else {

                order.push(questionKey);

            }



            llmModalState.rankingOrder = order;



            const entry = getLLMEntry(questionKey);

            if (entry) {

                entry.trashed = false;

            }



            persistLLMModalTrashState(questionKey, false);

            renderLLMStepOne();

            renderLLMStepTwo();



            if (llmModalState.step === 3) {

                renderLLMAccordion();

            }

        }



        function moveLLMQuestionToTrash(questionKey) {

            if (!questionKey) {

                return;

            }



            const validKeys = llmModalState.questions.map(entry => entry.questionKey);

            if (!validKeys.includes(questionKey)) {

                return;

            }



            llmModalState.rankingOrder = (llmModalState.rankingOrder || []).filter(key => key !== questionKey);

            if (!llmModalState.trashOrder.includes(questionKey)) {

                llmModalState.trashOrder.push(questionKey);

            }



            const entry = getLLMEntry(questionKey);

            if (entry) {

                entry.trashed = true;

            }



            if (llmModalState.editingKey === questionKey) {

                llmModalState.editingKey = null;

            }



            if (llmModalState.openQuestionKey === questionKey) {

                llmModalState.openQuestionKey = llmModalState.rankingOrder[0] || llmModalState.trashOrder[0] || null;

            }



            persistLLMModalTrashState(questionKey, true);

            renderLLMStepOne();

            renderLLMStepTwo();



            if (llmModalState.step === 3) {

                renderLLMAccordion();

            }

        }



        function renderLLMStepTwo() {

            const rankingList = document.getElementById('llm-ranking-list');

            const trashList = document.getElementById('llm-ranking-trash-list');

            const rankingEmpty = document.getElementById('llm-ranking-empty');

            const trashEmpty = document.getElementById('llm-ranking-trash-empty');



            if (!rankingList || !trashList) {

                return;

            }



            rankingList.innerHTML = '';

            trashList.innerHTML = '';



            const rankingKeys = llmModalState.rankingOrder || [];

            const trashKeys = llmModalState.trashOrder || [];



            rankingKeys.forEach((key, index) => {

                const item = createLLMListItem(key, index, 'ranking');

                if (item) {

                    rankingList.appendChild(item);

                }

            });



            trashKeys.forEach((key, index) => {

                const item = createLLMListItem(key, index, 'trash');

                if (item) {

                    trashList.appendChild(item);

                }

            });



            if (rankingEmpty) {

                rankingEmpty.style.display = rankingKeys.length ? 'none' : 'block';

            }



            if (trashEmpty) {

                trashEmpty.style.display = trashKeys.length ? 'none' : 'block';

            }



            attachLLMListListeners();

        }



        function renderLLMAccordion() {

            const accordion = document.getElementById('llm-accordion-list');

            if (!accordion) {

                return;

            }



            accordion.innerHTML = '';



            const combinedOrder = getCombinedLLMOrder();

            if (!combinedOrder.length) {

                const empty = document.createElement('div');

                empty.className = 'llm-empty-state';

                empty.textContent = 'No AI-generated questions are available for this segment.';

                accordion.appendChild(empty);

                return;

            }



            if (!combinedOrder.includes(llmModalState.openQuestionKey)) {

                llmModalState.openQuestionKey = combinedOrder[0];

            }



            combinedOrder.forEach(questionKey => {

                const entry = getLLMEntry(questionKey);

                if (!entry) {

                    return;

                }



                const item = document.createElement('div');

                item.className = 'llm-accordion-item';

                if (llmModalState.openQuestionKey === questionKey) {

                    item.classList.add('open');

                }

                if (entry.trashed) {

                    item.classList.add('trashed');

                }



                const header = document.createElement('button');

                header.type = 'button';

                header.className = 'llm-accordion-header';

                header.addEventListener('click', () => toggleLLMAccordion(questionKey));

                header.innerHTML = `

            <div class="llm-accordion-title">

                <span class="llm-item-type">${entry.type}</span>

                <span class="llm-item-question">${entry.question || '(empty question)'}</span>

            </div>

            <div class="llm-accordion-status">

                ${entry.trashed ? '<span class="llm-badge trashed">Trashed</span>' : ''}

            </div>

                `;

                item.appendChild(header);



                const panel = document.createElement('div');

                panel.className = 'llm-accordion-panel';



                const answerDisplay = document.createElement('div');

                answerDisplay.className = 'llm-answer-display';

                answerDisplay.innerHTML = `

            <strong>Answer</strong>

            <div class="llm-answer-text">${entry.answer ? entry.answer : '<span class="llm-answer-empty">(empty answer)</span>'}</div>

                `;

                panel.appendChild(answerDisplay);



                const actions = document.createElement('div');

                actions.className = 'llm-accordion-actions';



                const editButton = document.createElement('button');

                editButton.type = 'button';

                editButton.className = 'btn btn-secondary btn-icon';

                editButton.innerHTML = '<span aria-hidden="true">&#9998;</span>';

                editButton.title = 'Edit question and answer';

                editButton.disabled = entry.trashed;

                editButton.addEventListener('click', () => startLLMModalEdit(questionKey));

                actions.appendChild(editButton);



                if (entry.trashed) {

                    const restoreButton = document.createElement('button');

                    restoreButton.type = 'button';

                    restoreButton.className = 'btn btn-light btn-sm';

                    restoreButton.textContent = 'Restore';

                    restoreButton.addEventListener('click', () => moveLLMQuestionToRanking(questionKey));

                    actions.appendChild(restoreButton);

                }



                panel.appendChild(actions);



                if (llmModalState.editingKey === questionKey && !entry.trashed) {

                    const editWrapper = document.createElement('div');

                    editWrapper.className = 'llm-edit-form';



                    const questionField = document.createElement('div');

                    questionField.className = 'llm-modal-field';

                    const qLabel = document.createElement('label');

                    qLabel.textContent = 'Question';

                    const qInput = document.createElement('textarea');

                    qInput.value = entry.question || '';

                    qInput.dataset.role = 'question';

                    questionField.appendChild(qLabel);

                    questionField.appendChild(qInput);



                    const answerField = document.createElement('div');

                    answerField.className = 'llm-modal-field';

                    const aLabel = document.createElement('label');

                    aLabel.textContent = 'Answer';

                    const aInput = document.createElement('textarea');

                    aInput.value = entry.answer || '';

                    aInput.dataset.role = 'answer';

                    answerField.appendChild(aLabel);

                    answerField.appendChild(aInput);



                    const editActions = document.createElement('div');

                    editActions.className = 'llm-edit-actions';

                    const saveButton = document.createElement('button');

                    saveButton.type = 'button';

                    saveButton.className = 'btn btn-success btn-sm';

                    saveButton.textContent = 'Save';

                    saveButton.addEventListener('click', () => saveLLMModalQuestion(questionKey, editWrapper));

                    const cancelButton = document.createElement('button');

                    cancelButton.type = 'button';

                    cancelButton.className = 'btn btn-secondary btn-sm';

                    cancelButton.textContent = 'Cancel';

                    cancelButton.addEventListener('click', cancelLLMModalEdit);



                    editActions.appendChild(saveButton);

                    editActions.appendChild(cancelButton);



                    editWrapper.appendChild(questionField);

                    editWrapper.appendChild(answerField);

                    editWrapper.appendChild(editActions);



                    panel.appendChild(editWrapper);

                }



                item.appendChild(panel);

                accordion.appendChild(item);

            });

        }



        function toggleLLMAccordion(questionKey) {

            if (llmModalState.openQuestionKey === questionKey) {

                llmModalState.openQuestionKey = null;

            } else {

                llmModalState.openQuestionKey = questionKey;

            }

            renderLLMAccordion();

        }



        function getLLMEntry(questionKey) {

            return llmModalState.questions.find(entry => entry.questionKey === questionKey) || null;

        }



        function startLLMModalEdit(questionKey) {

            const entry = getLLMEntry(questionKey);

            if (!entry || entry.trashed) {

                return;

            }



            llmModalState.openQuestionKey = questionKey;

            llmModalState.editingKey = questionKey;

            renderLLMAccordion();

        }



        function cancelLLMModalEdit() {

            llmModalState.editingKey = null;

            renderLLMAccordion();

        }



        function persistLLMModalQuestionEdit(questionKey, updates) {

            if (!currentVideoId || !questionKey) {

                return;

            }



            if (!llmQuestionEdits[currentVideoId]) {

                llmQuestionEdits[currentVideoId] = {};

            }



            if (!llmQuestionEdits[currentVideoId][questionKey]) {

                llmQuestionEdits[currentVideoId][questionKey] = {};

            }



            const target = llmQuestionEdits[currentVideoId][questionKey];

            if (updates.question !== undefined) {

                target.question = updates.question;

            }

            if (updates.answer !== undefined) {

                target.answer = updates.answer;

            }

            if (updates.trashed !== undefined) {

                target.trashed = updates.trashed;

            }

            target.modified = true;

            target.timestamp = new Date().toISOString();

        }



        function persistLLMModalTrashState(questionKey, trashed) {

            persistLLMModalQuestionEdit(questionKey, { trashed });

        }



        function saveLLMModalQuestion(questionKey, editWrapper) {

            const entry = getLLMEntry(questionKey);

            if (!entry) {

                return;

            }



            const questionField = editWrapper.querySelector('textarea[data-role="question"]');

            const answerField = editWrapper.querySelector('textarea[data-role="answer"]');



            const updatedQuestion = questionField ? questionField.value.trim() : '';

            const updatedAnswer = answerField ? answerField.value.trim() : '';



            entry.question = updatedQuestion;

            entry.answer = updatedAnswer;

            entry.modified = true;

            entry.timestamp = new Date().toISOString();



            persistLLMModalQuestionEdit(questionKey, {

                question: updatedQuestion,

                answer: updatedAnswer

            });



            llmModalState.editingKey = null;



            const feedback = document.getElementById('llm-modal-feedback');

            if (feedback) {

                feedback.textContent = 'Saved edits.';

                setTimeout(() => {

                    if (feedback.textContent === 'Saved edits.') {

                        feedback.textContent = '';

                    }

                }, 1500);

            }



            renderLLMAccordion();

            renderLLMStepOne();

        }



        function getCombinedLLMOrder() {

            const seen = new Set();

            const combined = [];



            (llmModalState.rankingOrder || []).forEach(key => {

                if (!seen.has(key)) {

                    combined.push(key);

                    seen.add(key);

                }

            });



            (llmModalState.trashOrder || []).forEach(key => {

                if (!seen.has(key)) {

                    combined.push(key);

                    seen.add(key);

                }

            });



            llmModalState.questions.forEach(entry => {

                if (!seen.has(entry.questionKey)) {

                    combined.push(entry.questionKey);

                    seen.add(entry.questionKey);

                }

            });



            return combined;

        }



        function handleLLMStepNext() {

            if (!llmModalState.open) {

                return;

            }



            const feedback = document.getElementById('llm-modal-feedback');

            if (feedback) {

                feedback.textContent = '';

            }



            if (llmModalState.step === 1) {

                const triageCommentInput = document.getElementById('llm-triage-comment');

                const comment = triageCommentInput ? triageCommentInput.value.trim() : '';

                llmModalState.triageComment = comment;

                setLLMStep(2);

                return;

            }



            if (llmModalState.step === 2) {

                const rankingCommentInput = document.getElementById('llm-ranking-comment');

                const comment = rankingCommentInput ? rankingCommentInput.value.trim() : '';

                llmModalState.rankingComment = comment;

                setLLMStep(3);

                return;

            }

        }



        function handleLLMStepBack() {

            if (!llmModalState.open) {

                return;

            }



            const feedback = document.getElementById('llm-modal-feedback');

            if (feedback) {

                feedback.textContent = '';

            }



            if (llmModalState.step === 2) {

                setLLMStep(1);

                return;

            }



            if (llmModalState.step === 3) {

                setLLMStep(2);

            }

        }



        function handleLLMModalSubmit() {

            if (!llmModalState.open || !currentVideoId || !llmModalState.segmentKey) {

                closeLLMReviewModal();

                releaseModalPlaybackLock({ resume: false });

                approveAndContinue();

                if (typeof llmModalResolve === 'function') {

                    llmModalResolve();

                    llmModalResolve = null;

                }

                return;

            }



            if (llmModalState.step !== 3) {

                if (llmModalState.step === 1) {

                    setLLMStep(2);

                } else if (llmModalState.step === 2) {

                    setLLMStep(3);

                }

                return;

            }



            const rankingCommentInput = document.getElementById('llm-ranking-comment');

            const rankingComment = rankingCommentInput ? rankingCommentInput.value.trim() : (llmModalState.rankingComment || '').trim();

            llmModalState.rankingComment = rankingComment;



            const triageComment = (llmModalState.triageComment || '').trim();



            const validKeys = llmModalState.questions.map(entry => entry.questionKey);

            const rankingOrder = (llmModalState.rankingOrder || []).filter(key => validKeys.includes(key));

            const trashOrder = (llmModalState.trashOrder || []).filter(key => validKeys.includes(key));



            if (!llmQuestionEdits[currentVideoId]) {

                llmQuestionEdits[currentVideoId] = {};

            }



            llmQuestionEdits[currentVideoId][`${llmModalState.segmentKey}_ranking`] = {

                order: rankingOrder,

                trashed: trashOrder,

                triageComment,

                rankingComment,

                comment: rankingComment,

                updatedAt: new Date().toISOString()

            };



            closeLLMReviewModal();

            releaseModalPlaybackLock({ resume: false });

            renderReviewQuestions();

            approveAndContinue();



            if (typeof llmModalResolve === 'function') {

                llmModalResolve();

                llmModalResolve = null;

            }

        }



        function getSelectedVideoLabel() {
            if (currentVideoLabel) {
                return currentVideoLabel;
            }
            const select = document.getElementById('video-select');
            if (select && select.selectedIndex >= 0) {
                const option = select.options[select.selectedIndex];
                if (option) {
                    return option.textContent;
                }
            }
            return currentVideoId || '';
        }

        function resetReviewPanel() {
            const reviewVideo = document.getElementById('review-video-id');
            const reviewSegments = document.getElementById('review-total-segments');
            const reviewList = document.getElementById('review-questions-list');

            if (reviewVideo) {
                reviewVideo.textContent = currentVideoId ? getSelectedVideoLabel() : 'Not selected';
            }

            if (reviewSegments) {
                reviewSegments.textContent = currentSegments && currentSegments.length ? currentSegments.length : '0';
            }

            if (reviewList) {
                if (currentVideoId) {
                    reviewList.innerHTML = '<div class="review-placeholder">Choose "Review Questions" to generate a full summary.</div>';
                } else {
                    reviewList.innerHTML = '<div class="review-placeholder">Select a video on Step 1 to begin.</div>';
                }
            }
        }

        function updateReviewButtonState() {
            const reviewButton = document.getElementById('review-button');
            if (reviewButton) {
                reviewButton.disabled = !(currentSegments && currentSegments.length > 0);
            }
        }

        async function handleReviewQuestions() {
            if (!currentVideoId) {
                showStatus('Select a video before reviewing questions.', 'info');
                return;
            }

            if (!currentSegments || currentSegments.length === 0) {
                showStatus('No question segments available to review yet.', 'info');
                return;
            }

            unlockStep(3);
            await renderReviewQuestions();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        async function renderReviewQuestions() {
            const reviewVideo = document.getElementById('review-video-id');
            const reviewSegments = document.getElementById('review-total-segments');
            const reviewList = document.getElementById('review-questions-list');

            if (!reviewList) {
                return;
            }

            if (reviewVideo) {
                reviewVideo.textContent = getSelectedVideoLabel() || 'Not selected';
            }

            if (reviewSegments) {
                reviewSegments.textContent = currentSegments.length.toString();
            }

            if (!currentSegments || currentSegments.length === 0) {
                reviewList.innerHTML = '<div class="review-placeholder">No question segments available for this video.</div>';
                return;
            }

            reviewList.innerHTML = '';

            // Initialize llmQuestionEdits and segmentApprovals if needed
            if (!llmQuestionEdits[currentVideoId]) {
                llmQuestionEdits[currentVideoId] = {};
            }
            if (!segmentApprovals[currentVideoId]) {
                segmentApprovals[currentVideoId] = {};
            }

            // Create accordion for each segment
            for (let index = 0; index < currentSegments.length; index++) {
                const segment = currentSegments[index];
                const segmentKey = getSegmentKey(segment);
                const questions = await resolveSegmentQuestions(segment);
                
                const accordionItem = document.createElement('div');
                accordionItem.className = 'accordion-item';

                // Create accordion header
                const header = document.createElement('div');
                header.className = 'accordion-header';
                if (index === 0 && !segmentApprovals[currentVideoId][segmentKey]) {
                    header.classList.add('active');
                }
                
                // Add approved class if segment is approved
                if (segmentApprovals[currentVideoId][segmentKey]) {
                    header.classList.add('approved');
                }
                
                const title = document.createElement('div');
                title.className = 'accordion-title';
                title.innerHTML = `
                    <span class="segment-index">Segment ${index + 1}</span>
                    <span class="segment-time">${formatTime(segment.start)} - ${formatTime(segment.end)}</span>
                `;
                
                const arrow = document.createElement('span');
                arrow.className = 'accordion-arrow';
                arrow.innerHTML = '&#9662;';
                
                header.appendChild(title);
                header.appendChild(arrow);
                
                // Create accordion content
                const content = document.createElement('div');
                content.className = 'accordion-content';
                if (index === 0 && !segmentApprovals[currentVideoId][segmentKey]) {
                    content.classList.add('active');
                }
                
                const inner = document.createElement('div');
                inner.className = 'accordion-inner';
                
                // Left column - Expert Questions
                const expertColumn = document.createElement('div');
                expertColumn.className = 'question-column expert-column';
                
                const expertHeader = document.createElement('div');
                expertHeader.className = 'column-header';
                expertHeader.textContent = 'Expert Questions';
                expertColumn.appendChild(expertHeader);
                
                // Get expert question for this segment
                const expertEntry = getExpertQuestionForSegment(segment);
                
                // Also find manual questions that fall within this segment
                const manualQuestionsInSegment = [];
                Object.entries(expertQuestions).forEach(([key, entry]) => {
                    if (entry && entry.isManual && entry.timestamp >= segment.start && entry.timestamp <= segment.end) {
                        manualQuestionsInSegment.push(entry);
                    }
                });
                
                // Display segment expert question first
                if (expertEntry && !expertEntry.isManual) {
                    const expertDiv = document.createElement('div');
                    expertDiv.className = 'expert-question-display';
                    
                    if (expertEntry.skipped) {
                        expertDiv.classList.add('skipped');
                        expertDiv.innerHTML = `
                            <div class="question-type-label">SKIPPED</div>
                            <div style="color: #dd6b20;">Segment marked as skipped</div>
                            ${expertEntry.skipReason ? `<div style="color: #9c4221; font-size: 0.9rem;">Reason: ${expertEntry.skipReason}</div>` : ''}
                        `;
                    } else {
                        expertDiv.innerHTML = `
                            <div class="question-type-label">${getExpertQuestionTypeLabel(expertEntry.questionType)}</div>
                            <div style="font-weight: 600; margin-bottom: 8px;">${expertEntry.question || 'No question'}</div>
                            <div style="color: #4a5568;">Answer: ${expertEntry.answer || 'No answer'}</div>
                        `;
                    }
                    expertColumn.appendChild(expertDiv);
                }
                
                // Display manual questions in this segment
                if (manualQuestionsInSegment.length > 0) {
                    manualQuestionsInSegment.forEach(manualEntry => {
                        const manualDiv = document.createElement('div');
                        manualDiv.className = 'expert-question-display';
                        manualDiv.style.borderLeft = '4px solid #38a169';
                        manualDiv.style.marginTop = '12px';
                        
                        manualDiv.innerHTML = `
                            <div style="font-size: 0.8rem; color: #38a169; margin-bottom: 6px;">Manual @ ${formatTime(manualEntry.timestamp)}</div>
                            <div class="question-type-label" style="background: #38a169;">${getExpertQuestionTypeLabel(manualEntry.questionType)}</div>
                            <div style="font-weight: 600; margin-bottom: 8px;">${manualEntry.question || 'No question'}</div>
                            <div style="color: #4a5568;">Answer: ${manualEntry.answer || 'No answer'}</div>
                        `;
                        expertColumn.appendChild(manualDiv);
                    });
                }
                
                if (!expertEntry && manualQuestionsInSegment.length === 0) {
                    expertColumn.innerHTML += '<div style="color: #718096; text-align: center; padding: 20px;">No expert question added yet</div>';
                }
                
                // Right column - LLM Questions (Editable)
                const llmColumn = document.createElement('div');
                llmColumn.className = 'question-column llm-column';
                
                const llmHeader = document.createElement('div');
                llmHeader.className = 'column-header';
                llmHeader.textContent = 'AI-Generated Questions (Editable)';
                llmColumn.appendChild(llmHeader);
                
                if (questions && typeof questions === 'object' && Object.keys(questions).length > 0) {
                    // First, identify the best question
                    let bestQuestionText = null;
                    if (segment.result && segment.result.best_question) {
                        bestQuestionText = segment.result.best_question;
                    }
                    
                    // Check for expert-selected best question
                    const expertBestKey = llmQuestionEdits[currentVideoId] && 
                                         llmQuestionEdits[currentVideoId][`${segmentKey}_expertBest`];
                    
                    Object.entries(questions).forEach(([type, data]) => {
                        const questionKey = `${segmentKey}_${type}`;
                        
                        // Get any existing edits for this question
                        const edits = llmQuestionEdits[currentVideoId][questionKey] || {};
                        const isTrashed = edits.trashed || false;
                        const currentQuestion = edits.question !== undefined ? edits.question : (data.q || '');
                        const currentAnswer = edits.answer !== undefined ? edits.answer : (data.a || '');
                        
                        // Check if this is the best question
                        const isAIBestQuestion = bestQuestionText && (data.q === bestQuestionText);
                        const isExpertBestQuestion = expertBestKey === questionKey;
                        
                        const editableDiv = document.createElement('div');
                        editableDiv.className = 'editable-question collapsed';
                        editableDiv.id = `question-${questionKey}`;
                        if (isTrashed) editableDiv.classList.add('trashed');
                        if (isAIBestQuestion || isExpertBestQuestion) editableDiv.classList.add('best-question');
                        
                        editableDiv.innerHTML = `
                            <div class="question-header">
                                <div class="question-summary" onclick="toggleEditMode('${questionKey}', false)">
                                    <div>
                                        <span class="question-type-label">${type}</span>
                                        ${isAIBestQuestion ? '<span class="best-indicator">AI BEST</span>' : ''}
                                        ${isExpertBestQuestion ? '<span class="best-indicator" style="background: #27ae60;">EXPERT BEST</span>' : ''}
                                    </div>
                                    <div class="question-preview">${currentQuestion}</div>
                                    <div class="answer-preview">${currentAnswer}</div>
                                </div>
                                <div class="question-actions">
                                     <!-- Read-only view - no actions available -->
                                </div>
                            </div>
                            <div class="question-field">
                                <label>Question:</label>
                                <textarea id="edit-question-${questionKey}" data-field="question" data-key="${questionKey}" ${isTrashed ? 'disabled' : ''}>${currentQuestion}</textarea>
                            </div>
                            <div class="question-field">
                                <label>Answer:</label>
                                <textarea id="edit-answer-${questionKey}" data-field="answer" data-key="${questionKey}" ${isTrashed ? 'disabled' : ''}>${currentAnswer}</textarea>
                            </div>
                            <div class="question-field">
                                <div class="question-actions">
                                    <button class="btn-icon btn-save-edit" onclick="saveEditAndClose('${questionKey}')">Save</button>
                                    <button class="btn-icon btn-cancel-edit" onclick="toggleEditMode('${questionKey}', false)">Cancel</button>
                                </div>
                            </div>
                        `;
                        
                        llmColumn.appendChild(editableDiv);
                    });
                } else {
                    llmColumn.innerHTML += '<div style="color: #718096; text-align: center; padding: 20px;">No AI-generated questions for this segment</div>';
                }
                
                inner.appendChild(expertColumn);
                inner.appendChild(llmColumn);
                content.appendChild(inner);
                
                // Add approve segment button for ALL segments
                const approveSection = document.createElement('div');
                approveSection.className = 'segment-approve-section';
                approveSection.style.gridColumn = '2';
                approveSection.style.marginTop = '0';
                
                // Show approve button regardless of AI questions
                approveSection.innerHTML = `
                    <button class="btn-approve-segment" 
                            onclick="approveSegment('${segmentKey}', ${index})"
                            ${segmentApprovals[currentVideoId][segmentKey] ? 'disabled' : ''}>
                        ${segmentApprovals[currentVideoId][segmentKey] ? 'Segment Approved ?' : 'Approve Segment'}
                    </button>
                `;
                
                llmColumn.appendChild(approveSection);
                
                // Add header click handler
                header.addEventListener('click', () => toggleAccordion(index));
                
                accordionItem.appendChild(header);
                accordionItem.appendChild(content);
                reviewList.appendChild(accordionItem);
            }
            
            // Add save button
            const saveSection = document.createElement('div');
            saveSection.style.textAlign = 'center';
            saveSection.innerHTML = `
                <button class="btn-save-changes" onclick="saveAllLLMEdits()">Finalize questions and submit</button>
            `;
            reviewList.appendChild(saveSection);
        }
        
        function approveSegment(segmentKey, segmentIndex) {
            if (!segmentApprovals[currentVideoId]) {
                segmentApprovals[currentVideoId] = {};
            }
            
            // Mark segment as approved (no validation required)
            segmentApprovals[currentVideoId][segmentKey] = true;
            
            // Close current accordion
            const headers = document.querySelectorAll('.accordion-header');
            const contents = document.querySelectorAll('.accordion-content');
            
            if (headers[segmentIndex]) {
                headers[segmentIndex].classList.remove('active');
                headers[segmentIndex].classList.add('approved');
                contents[segmentIndex].classList.remove('active');
            }
            
            // Open next unapproved segment
            for (let i = segmentIndex + 1; i < currentSegments.length; i++) {
                const nextSegmentKey = getSegmentKey(currentSegments[i]);
                if (!segmentApprovals[currentVideoId][nextSegmentKey]) {
                    headers[i].classList.add('active');
                    contents[i].classList.add('active');
                    break;
                }
            }
            
            // Re-render to update UI
            renderReviewQuestions();
        }

        function toggleAccordion(index) {
            const headers = document.querySelectorAll('.accordion-header');
            const contents = document.querySelectorAll('.accordion-content');
            
            headers.forEach((header, i) => {
                if (i === index) {
                    header.classList.toggle('active');
                    contents[i].classList.toggle('active');
                } else {
                    header.classList.remove('active');
                    contents[i].classList.remove('active');
                }
            });
        }

        function toggleEditMode(questionKey, editMode) {
            const questionDiv = document.getElementById(`question-${questionKey}`);
            if (!questionDiv) return;
            
            if (editMode) {
                questionDiv.classList.remove('collapsed');
                questionDiv.classList.add('editing');
                
                // Focus on the question textarea
                const questionTextarea = document.getElementById(`edit-question-${questionKey}`);
                if (questionTextarea) {
                    questionTextarea.focus();
                }
            } else {
                questionDiv.classList.add('collapsed');
                questionDiv.classList.remove('editing');
            }
        }
        
        function saveEditAndClose(questionKey) {
            const questionTextarea = document.getElementById(`edit-question-${questionKey}`);
            const answerTextarea = document.getElementById(`edit-answer-${questionKey}`);
            
            if (questionTextarea && answerTextarea) {
                saveLLMQuestionEdit(questionKey, 'question', questionTextarea.value);
                saveLLMQuestionEdit(questionKey, 'answer', answerTextarea.value);
                
                // Update the preview text
                const questionDiv = document.getElementById(`question-${questionKey}`);
                if (questionDiv) {
                    const previewQuestion = questionDiv.querySelector('.question-preview');
                    const previewAnswer = questionDiv.querySelector('.answer-preview');
                    
                    if (previewQuestion) previewQuestion.textContent = questionTextarea.value;
                    if (previewAnswer) previewAnswer.textContent = answerTextarea.value;
                }
            }
            
            toggleEditMode(questionKey, false);
        }
        
        function saveLLMQuestionEdit(questionKey, field, value) {
            if (!llmQuestionEdits[currentVideoId]) {
                llmQuestionEdits[currentVideoId] = {};
            }
            
            if (!llmQuestionEdits[currentVideoId][questionKey]) {
                llmQuestionEdits[currentVideoId][questionKey] = {};
            }
            
            llmQuestionEdits[currentVideoId][questionKey][field] = value;
            llmQuestionEdits[currentVideoId][questionKey].modified = true;
            llmQuestionEdits[currentVideoId][questionKey].timestamp = new Date().toISOString();
        }

        function trashLLMQuestion(questionKey) {
            if (!llmQuestionEdits[currentVideoId]) {
                llmQuestionEdits[currentVideoId] = {};
            }
            
            if (!llmQuestionEdits[currentVideoId][questionKey]) {
                llmQuestionEdits[currentVideoId][questionKey] = {};
            }
            
            llmQuestionEdits[currentVideoId][questionKey].trashed = true;
            llmQuestionEdits[currentVideoId][questionKey].timestamp = new Date().toISOString();
            
            // Re-render to update UI
            renderReviewQuestions();
        }

        function restoreLLMQuestion(questionKey) {
            if (llmQuestionEdits[currentVideoId] && llmQuestionEdits[currentVideoId][questionKey]) {
                llmQuestionEdits[currentVideoId][questionKey].trashed = false;
                llmQuestionEdits[currentVideoId][questionKey].timestamp = new Date().toISOString();
            }
            
            // Re-render to update UI
            renderReviewQuestions();
        }

        function setExpertBestQuestion(segmentKey, questionKey) {
            if (!llmQuestionEdits[currentVideoId]) {
                llmQuestionEdits[currentVideoId] = {};
            }
            
            // Store the expert's best question selection
            if (questionKey) {
                llmQuestionEdits[currentVideoId][`${segmentKey}_expertBest`] = questionKey;
            } else {
                delete llmQuestionEdits[currentVideoId][`${segmentKey}_expertBest`];
            }
            
            // Re-render to update UI
            renderReviewQuestions();
        }

        async function saveAllLLMEdits() {
            if (!currentVideoId) {
                showStatus('No video selected', 'error');
                return;
            }

            // Ensure all segments are approved
            let allApproved = true;
            for (let index = 0; index < currentSegments.length; index++) {
                const segment = currentSegments[index];
                const segmentKey = getSegmentKey(segment);
                if (!segmentApprovals[currentVideoId] || !segmentApprovals[currentVideoId][segmentKey]) {
                    allApproved = false;
                    break;
                }
            }

            if (!allApproved) {
                showStatus('Please approve all segments before saving changes', 'error');
                return;
            }

            // Build final JSON payload
            const finalQuestions = {
                videoId: currentVideoId,
                timestamp: new Date().toISOString(),
                segments: []
            };

            for (let index = 0; index < currentSegments.length; index++) {
                const segment = currentSegments[index];
                const segmentKey = getSegmentKey(segment);

                const segmentData = {
                    segmentIndex: index,
                    start: segment.start,
                    end: segment.end,
                    aiQuestions: [],
                    aiOriginalBest: null,
                    approved: true
                };

                const questions = await resolveSegmentQuestions(segment);
                if (questions) {
                    if (segment.result && segment.result.best_question) {
                        segmentData.aiOriginalBest = segment.result.best_question;
                    }

                    // Get ranking info
                    const rankingInfo = llmQuestionEdits[currentVideoId] && 
                                    llmQuestionEdits[currentVideoId][`${segmentKey}_ranking`];

                    Object.entries(questions).forEach(([type, data]) => {
                        const questionKey = `${segmentKey}_${type}`;
                        const edits = (llmQuestionEdits[currentVideoId] &&
                                    llmQuestionEdits[currentVideoId][questionKey]) || {};

                        // Determine ranking
                        let ranking = 0;
                        if (rankingInfo && rankingInfo.order) {
                            const rankIndex = rankingInfo.order.indexOf(questionKey);
                            if (rankIndex !== -1) {
                                ranking = rankIndex + 1; // 1-based ranking
                            }
                        }
                        
                        // If trashed, ranking is 0
                        if (edits.trashed || (rankingInfo && rankingInfo.trashed && 
                            rankingInfo.trashed.includes(questionKey))) {
                            ranking = 0;
                        }

                        const questionData = {
                            type,
                            originalQuestion: data.q || '',
                            originalAnswer: data.a || '',
                            editedQuestion: edits.question !== undefined ? edits.question : (data.q || ''),
                            editedAnswer: edits.answer !== undefined ? edits.answer : (data.a || ''),
                            trashed: edits.trashed || false,
                            modified: edits.modified || false,
                            ranking: ranking // Add ranking here
                        };

                        if (edits.timestamp) {
                            questionData.lastModified = edits.timestamp;
                        }

                        segmentData.aiQuestions.push(questionData);
                    });

                    // Add ranking comment if exists
                    if (rankingInfo) {
                        if (rankingInfo.triageComment) {
                            segmentData.triageComment = rankingInfo.triageComment;
                        }
                        const resolvedRankingComment = rankingInfo.rankingComment || rankingInfo.comment;
                        if (resolvedRankingComment) {
                            segmentData.rankingComment = resolvedRankingComment;
                        }
                    }
                }

                finalQuestions.segments.push(segmentData);
            }

            try {
                // Use the new dedicated endpoint
                const response = await fetch('/api/save-final-questions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        videoId: currentVideoId,
                        data: finalQuestions
                    })
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    showStatus('Successfully saved final questions to final_questions folder!', 'success');
                    console.log('Saved to:', result.filepath);

                    // Save to localStorage as backup
                    localStorage.setItem(`final_questions_${currentVideoId}`, JSON.stringify(finalQuestions));

                    // Update button to show success
                    const btn = document.querySelector('.btn-save-changes');
                    if (btn) {
                        btn.disabled = true;
                        btn.textContent = 'Saved to final_questions ?';
                        setTimeout(() => {
                            btn.disabled = false;
                            btn.textContent = 'Finalize questions and submit';
                        }, 3000);
                    }
                } else {
                    throw new Error(result.message || 'Server save failed');
                }
            } catch (error) {
                console.error('Error saving final questions:', error);
                // Fallback to localStorage
                localStorage.setItem(`final_questions_${currentVideoId}`, JSON.stringify(finalQuestions));
                showStatus('Saved to browser storage. Error: ' + error.message, 'warning');
            }
        }

        // Load saved edits when video is loaded
        function loadLLMEdits(videoId) {
            const savedEdits = localStorage.getItem(`llm_edits_${videoId}`);
            if (savedEdits) {
                llmQuestionEdits[videoId] = JSON.parse(savedEdits);
            } else {
                llmQuestionEdits[videoId] = {};
            }
        }

        function ensureSegmentResultObject(segment) {
            if (!segment) {
                return;
            }

            if (!segment.result) {
                segment.result = {};
                return;
            }

            if (typeof segment.result === 'string') {
                try {
                    segment.result = JSON.parse(segment.result);
                } catch (error) {
                    segment.result = {};
                }
            }
        }

        async function resolveSegmentQuestions(segment) {
            if (!segment) {
                return null;
            }

            ensureSegmentResultObject(segment);

            if (segment.result && segment.result.questions) {
                return segment.result.questions;
            }

            const filename = `questions_${String(segment.start).padStart(5, '0')}-${String(segment.end).padStart(5, '0')}.json`;

            try {
                const response = await fetch(`/downloads/${currentVideoId}/questions/${filename}`);
                if (response.ok) {
                    const data = await response.json();
                    ensureSegmentResultObject(segment);
                    if (data.questions) {
                        segment.result.questions = data.questions;
                    }
                    if (data.best_question && !segment.result.best_question) {
                        segment.result.best_question = data.best_question;
                    }
                    return segment.result.questions || null;
                }
            } catch (error) {
                console.warn('Unable to resolve questions for segment', error);
            }

            return null;
        }

        async function loadVideoList() {
            const list = document.getElementById('video-card-list');
            if (list) {
                list.innerHTML = '<div class="video-list-empty">Loading videos...</div>';
            }

            try {
                const response = await fetch('/api/videos-list');
                const data = await response.json();

                if (data.success && Array.isArray(data.videos)) {
                    availableVideos = data.videos;

                    if (currentVideoId && !findVideoById(currentVideoId)) {
                        currentVideoId = null;
                        currentVideoLabel = '';
                        currentSegments = [];
                        currentSegmentIndex = 0;
                        resetReviewPanel();
                        updateReviewButtonState();
                    }

                    renderVideoList();
                } else {
                    availableVideos = [];
                    renderVideoList();
                }
            } catch (error) {
                availableVideos = [];
                renderVideoList();
            }
        }

        async function loadVideo(videoIdParam = null, labelOverride = null) {
            let videoId = videoIdParam;
            let displayLabel = labelOverride;

            if (!videoId) {
                const select = document.getElementById('video-select');
                if (select) {
                    videoId = select.value;
                    if (select.selectedIndex >= 0) {
                        const option = select.options[select.selectedIndex];
                        displayLabel = option ? option.textContent : null;
                    }
                }
            }

            if (!videoId) {
                showStatus('Choose a video to begin reviewing.', 'info');
                return;
            }

            const videoMeta = findVideoById(videoId);

            if (!displayLabel) {
                if (videoMeta) {
                    const baseLabel = videoMeta.title || videoMeta.id;
                    const durationLabel = videoMeta.duration ? formatDuration(videoMeta.duration) : '';
                    displayLabel = durationLabel ? `${baseLabel} (${durationLabel})` : baseLabel;
                } else {
                    displayLabel = videoId;
                }
            }

            currentVideoId = videoId;
            currentVideoLabel = displayLabel;
            currentSegments = [];
            currentSegmentIndex = 0;
            autoAdvanceEnabled = true;
            expertQuestions = {};
            pendingSegmentIndices = [];
            isLoadingVideo = true;
            
            // Load any saved LLM edits for this video
            loadLLMEdits(videoId);

            setVideoCardState(videoId, 'loading');

            maxAvailableStep = 1;
            updateStepAccess();
            showStep(1);

            resetReviewPanel();
            updateReviewButtonState();

            const timeline = document.getElementById('timeline-annotations');
            if (timeline) {
                timeline.style.display = 'none';
                timeline.innerHTML = '';
            }

            const overlay = document.getElementById('pause-overlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
            resetExpertForm();

            const segmentInfo = document.getElementById('segment-info');
            if (segmentInfo) {
                segmentInfo.style.display = 'none';
            }

            const approveSection = document.getElementById('approve-section');
            if (approveSection) {
                approveSection.style.display = 'none';
            }

            const expertPanel = document.getElementById('expert-questions');
            if (expertPanel) {
                expertPanel.innerHTML = '';
                renderExpertInfoMessage(expertPanel, 'Loading video...');
            }

            const progressText = document.getElementById('progress-text');
            if (progressText) {
                progressText.textContent = 'Loading segments...';
            }

            const progressFill = document.getElementById('progress-fill');
            if (progressFill) {
                progressFill.style.width = '0%';
            }

            let loadSucceeded = false;

            try {
                await loadVideoPlayer(videoId);
                await loadSegments(videoId);
                await loadExpertQuestionFiles(videoId);

                currentSegmentIndex = findNextIncompleteSegmentIndex(0);
                updateTimelinePausePoints();
                const nextSegment = currentSegments[currentSegmentIndex] || null;
                updateExpertQuestionsPanel(nextSegment);

                loadSucceeded = true;
            } catch (error) {
                const container = document.getElementById('video-container');
                if (container) {
                    container.innerHTML = '<div class="video-loading">Unable to load this video.</div>';
                }
            } finally {
                resetReviewPanel();
                updateReviewButtonState();
                updateProgress();
                if (loadSucceeded) {
                    unlockStep(2);
                }
                isLoadingVideo = false;
                setVideoCardState(videoId, loadSucceeded ? 'selected' : 'idle');
            }
        }

        async function loadVideoPlayer(videoId) {
            const container = document.getElementById('video-container');
            
            // Create video element
            const video = document.createElement('video');
            video.className = 'video-player';
            video.controls = true;
            video.preload = 'metadata';
            
            // Set video source - adjust path as needed
            video.src = `/downloads/${videoId}/${videoId}.mp4`;
            
            // Add event listeners
            video.addEventListener('timeupdate', onVideoTimeUpdate);
            video.addEventListener('loadedmetadata', onVideoLoaded);
            video.addEventListener('play', onVideoPlay);
            video.addEventListener('pause', onVideoPause);
            
            container.innerHTML = '';
            container.appendChild(video);
            
            videoElement = video;
            
            // Show timeline annotations
            document.getElementById('timeline-annotations').style.display = 'block';
        }
        
        async function loadSegments(videoId) {
            try {
                // Try multiple approaches to find question files
                await loadFromQuestionFiles(videoId);
            } catch (error) {
                console.error('Failed to load segments:', error);
                currentSegments = [];
                showStatus('Failed to load question segments', 'error');
            }

            createTimelinePausePoints();
        }

        async function loadExpertQuestionFiles(videoId) {
            expertQuestions = {};

            if (!videoId) {
                return;
            }

            try {
                const response = await fetch(`/api/expert-questions/${videoId}`);
                if (!response.ok) {
                    return;
                }

                const data = await response.json();
                if (!data || !data.success || !Array.isArray(data.questions)) {
                    return;
                }

                data.questions.forEach(entry => {
                    if (!entry) {
                        return;
                    }

                    const segmentStart = entry.segment_start ?? entry.segmentStart ?? 0;
                    const segmentEnd = entry.segment_end ?? entry.segmentEnd ?? 0;

                    const normalized = {
                        videoId: data.video_id || data.videoId || videoId,
                        segmentStart,
                        segmentEnd,
                        timestamp: entry.timestamp ?? segmentEnd,
                        questionType: normalizeQuestionType(entry.question_type ?? entry.questionType),
                        question: entry.question || '',
                        answer: entry.answer || '',
                        updatedAt: entry.updated_at ?? entry.updatedAt ?? null
                    };

                    const isSkipped = Boolean(entry.skipped ?? entry.skip);
                    normalized.skipped = isSkipped;
                    normalized.skipReason = entry.skip_reason ?? entry.skipReason ?? '';

                    setExpertQuestionForSegment({ start: segmentStart, end: segmentEnd }, normalized);
                });
            } catch (error) {
                console.warn('Unable to load expert questions for video', videoId, error);
            }
        }

        
        async function loadFromQuestionFiles(videoId) {
            try {
                // Simple approach - look for video_id.json file
                const filename = `${videoId}.json`;
                
                console.log(`Trying to load: /downloads/${videoId}/questions/${filename}`);
                const response = await fetch(`/downloads/${videoId}/questions/${filename}`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`Successfully loaded data from ${filename}:`, data);
                    
                    // Check for segments array
                    if (data.segments && Array.isArray(data.segments) && data.segments.length > 0) {
                        currentSegments = data.segments;
                        console.log('Successfully loaded segments:', currentSegments);
                        return;
                    } else {
                        console.log(`File ${filename} doesn't have segments array or it's empty`);
                    }
                } else {
                    console.log(`Failed to fetch ${filename}: ${response.status}`);
                }
                
                // If video_id.json not found, try individual question files
                console.log('No video_id.json file found, trying individual files');
                await loadFromIndividualQuestionFiles(videoId);
                
            } catch (error) {
                console.error('Error in loadFromQuestionFiles:', error);
                currentSegments = [];
            }
        }
        
        async function loadFromIndividualQuestionFiles(videoId) {
            try {
                // Try to find individual question files like questions_00000-00060.json
                const segments = [];
                
                // Try common time intervals
                const commonIntervals = [
                    { start: 0, end: 59 },
                    { start: 60, end: 119 }, 
                    { start: 120, end: 179 },
                    { start: 180, end: 239 },
                    { start: 240, end: 299 },
                    { start: 300, end: 359 }
                ];
                
                for (const interval of commonIntervals) {
                    const filename = `questions_${String(interval.start).padStart(5, '0')}-${String(interval.end).padStart(5, '0')}.json`;
                    try {
                        const response = await fetch(`/downloads/${videoId}/questions/${filename}`);
                        if (response.ok) {
                            const data = await response.json();
                            segments.push({
                                start: interval.start,
                                end: interval.end,
                                result: data
                            });
                        }
                    } catch (e) {
                        continue;
                    }
                }
                
                if (segments.length > 0) {
                    currentSegments = segments;
                    return;
                }
                
                // Final fallback - no questions found
                currentSegments = [];
                
            } catch (error) {
                console.error('Error loading individual question files:', error);
                currentSegments = [];
            }
        }
        
        function onVideoLoaded() {
            updateTimeDisplay();
            createTimelinePausePoints();

            if (videoElement) {
                videoElement.play();
            }

            const segmentInfo = document.getElementById('segment-info');
            if (segmentInfo) {
                segmentInfo.style.display = 'none';
            }

            const approveSection = document.getElementById('approve-section');
            if (approveSection) {
                approveSection.style.display = 'none';
            }

            const expertPanel = document.getElementById('expert-questions');
            if (expertPanel) {
                expertPanel.innerHTML = '';
                renderExpertInfoMessage(expertPanel, 'Video playing... Expert review will pause at segment endpoints.');
            }
        }
        
        function onVideoTimeUpdate() {
            updateTimeDisplay();
            checkForPausePoints();
        }
        
        function onVideoPlay() {
            document.getElementById('play-pause-btn').textContent = 'Pause';
            isVideoPaused = false;
        }
        
        function onVideoPause() {
            document.getElementById('play-pause-btn').textContent = 'Play';
            isVideoPaused = true;
        }
        
        function checkForPausePoints() {
            if (!videoElement || !autoAdvanceEnabled || currentSegments.length === 0) return;

            const currentTime = videoElement.currentTime;
            const overlayActive = document.getElementById('pause-overlay').classList.contains('active');

            for (let index = 0; index < currentSegments.length; index++) {
                const segment = currentSegments[index];
                if (!segment || hasExpertDecision(segment)) {
                    continue;
                }

                const endTime = Number(segment.end ?? 0);
                if (!Number.isFinite(endTime) || endTime <= 0) {
                    continue;
                }

                if (currentTime >= (endTime - REVIEW_TOLERANCE_BEFORE)) {
                    if (!pendingSegmentIndices.includes(index)) {
                        pendingSegmentIndices.push(index);
                        pendingSegmentIndices.sort((a, b) => a - b);
                    }
                }

                if (currentTime < (endTime - REVIEW_TOLERANCE_BEFORE)) {
                    break;
                }
            }

            if (!overlayActive && pendingSegmentIndices.length > 0) {
                const nextIndex = pendingSegmentIndices.shift();
                pauseForReview(nextIndex);
            }
        }
        
        
        function pauseForReview(targetIndex = currentSegmentIndex) {
            if (!videoElement || targetIndex < 0 || targetIndex >= currentSegments.length) {
                return;
            }

            currentSegmentIndex = targetIndex;

            const currentSegment = currentSegments[currentSegmentIndex];
            if (!currentSegment) {
                return;
            }

            videoElement.pause();
            const targetTime = Number(currentSegment.end ?? videoElement.currentTime);
            if (!Number.isNaN(targetTime) && targetTime >= 0) {
                const duration = videoElement.duration || targetTime;
                videoElement.currentTime = Math.min(targetTime, duration);
            }

            autoAdvanceEnabled = false;

            showPauseOverlay(currentSegment);
            loadCurrentSegmentData();
            updateTimelinePausePoints();
            updateProgress();
        }

        
        function loadCurrentSegmentData() {
            const segment = currentSegments[currentSegmentIndex];
            if (!segment) {
                updateExpertQuestionsPanel(null);
                return;
            }

            const segmentInfo = document.getElementById('segment-info');
            if (segmentInfo) {
                segmentInfo.style.display = 'block';
            }

            const timeText = `${formatTime(segment.start)} - ${formatTime(segment.end)}`;
            const duration = Math.max(0, segment.end - segment.start);

            const timeEl = document.getElementById('segment-time');
            if (timeEl) {
                timeEl.textContent = timeText;
            }

            const durationEl = document.getElementById('segment-duration');
            if (durationEl) {
                durationEl.textContent = `Duration: ${duration} seconds`;
            }

            updateExpertQuestionsPanel(segment);

            const approveSection = document.getElementById('approve-section');
            if (approveSection) {
                approveSection.style.display = 'block';
            }
        }
        
        async function loadAIQuestionsForSegment(segment) {
            updateExpertQuestionsPanel(segment);
        }
        
        function createTimelinePausePoints() {
            const timelineContainer = document.getElementById('timeline-annotations');
            timelineContainer.innerHTML = '';

            if (!videoElement || currentSegments.length === 0) return;

            const videoDuration = videoElement.duration || 600;

            currentSegments.forEach((segment, index) => {
                const pausePoint = document.createElement('div');
                pausePoint.className = 'timeline-pause-point';
                pausePoint.id = `timeline-point-${index}`;

                const leftPercent = (segment.end / videoDuration) * 100;
                pausePoint.style.left = leftPercent + '%';

                if (hasExpertDecision(segment)) {
                    pausePoint.classList.add('completed');
                } else if (index === currentSegmentIndex) {
                    pausePoint.classList.add('current');
                }

                pausePoint.title = `Segment ${index + 1}: ${formatTime(segment.start)}`;

                timelineContainer.appendChild(pausePoint);
            });
        }
        
        function updateTimelinePausePoints() {
            currentSegments.forEach((segment, index) => {
                const pausePoint = document.getElementById(`timeline-point-${index}`);
                if (!pausePoint) return;

                pausePoint.classList.remove('completed', 'current');

                if (hasExpertDecision(segment)) {
                    pausePoint.classList.add('completed');
                } else if (index === currentSegmentIndex) {
                    pausePoint.classList.add('current');
                }
            });
        }
        
        function approveAndContinue(message = null, statusType = 'success') {
            const currentSegment = currentSegments[currentSegmentIndex];

            if (currentSegment && !hasExpertDecision(currentSegment)) {
                const warning = 'Please add an expert question or mark the segment as skipped before continuing.';
                setExpertFormFeedback(warning);
                return;
            }

            clearCurrentQuestions();
            hidePauseOverlay();

            const segmentInfo = document.getElementById('segment-info');
            if (segmentInfo) {
                segmentInfo.style.display = 'none';
            }

            const approveSection = document.getElementById('approve-section');
            if (approveSection) {
                approveSection.style.display = 'none';
            }

            pendingSegmentIndices = pendingSegmentIndices.filter(index => index !== currentSegmentIndex);

            const processedIndex = currentSegmentIndex;
            const nextQueuedIndex = pendingSegmentIndices.length > 0 ? pendingSegmentIndices.shift() : null;

            if (nextQueuedIndex !== null && nextQueuedIndex !== undefined) {
                pauseForReview(nextQueuedIndex);
                return;
            }

            const nextIndex = findNextIncompleteSegmentIndex(processedIndex + 1);
            currentSegmentIndex = nextIndex;

            updateTimelinePausePoints();
            updateProgress();

            if (nextIndex >= currentSegments.length) {
                autoAdvanceEnabled = false;
                updateExpertQuestionsPanel(null);
                return;
            }

            autoAdvanceEnabled = true;

            const nextSegment = currentSegments[currentSegmentIndex] || null;
            updateExpertQuestionsPanel(nextSegment);

            if (videoElement && nextSegment) {
                const nextStart = Number(nextSegment.start ?? 0);
                if (!Number.isNaN(nextStart) && nextStart >= 0) {
                    videoElement.currentTime = Math.max(nextStart, 0);
                }
                videoElement.play();
            }
        }
        
        function clearCurrentQuestions() {
            const container = document.getElementById('expert-questions');
            if (!container) {
                return;
            }

            container.innerHTML = '';
            renderExpertInfoMessage(container, 'Continuing playback...');
        }
        
        function skipSegment() {
            return handleExpertSkip();
        }
        
        function showPauseOverlay(segment) {
            const overlay = document.getElementById('pause-overlay');
            if (!overlay) {
                return;
            }

            const segmentNumberEl = document.getElementById('expert-segment-number');
            if (segmentNumberEl) {
                segmentNumberEl.textContent = (currentSegmentIndex + 1).toString();
            }

            const segmentTimeEl = document.getElementById('expert-segment-time');
            if (segmentTimeEl) {
                segmentTimeEl.textContent = `${formatTime(segment.start)} - ${formatTime(segment.end)}`;
            }

            const pauseTimestampEl = document.getElementById('expert-pause-timestamp');
            if (pauseTimestampEl) {
                pauseTimestampEl.textContent = formatTime(segment.end);
            }

            populateExpertForm(segment);

            overlay.classList.add('active');
        }

        function hidePauseOverlay() {
            const overlay = document.getElementById('pause-overlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
            resetExpertForm();
        }
        
        function togglePlayPause() {
            if (!videoElement) return;
            
            if (videoElement.paused) {
                videoElement.play();
            } else {
                videoElement.pause();
            }
        }
        
        function jumpToSegment(direction) {
            const newIndex = currentSegmentIndex + direction;

            if (newIndex >= 0 && newIndex < currentSegments.length) {
                currentSegmentIndex = newIndex;

                const segment = currentSegments[currentSegmentIndex];
                if (videoElement && segment) {
                    const nextStart = Number(segment.start ?? 0);
                    videoElement.currentTime = Math.max(nextStart, 0);
                }

                autoAdvanceEnabled = true;
                hidePauseOverlay();
                updateProgress();
                updateTimelinePausePoints();
                updateExpertQuestionsPanel(currentSegments[currentSegmentIndex]);
            }
        }

        
        function seekVideo(seconds) {
            if (!videoElement) return;
            videoElement.currentTime = Math.max(0, videoElement.currentTime + seconds);
        }
        
        function updateTimeDisplay() {
            if (!videoElement) return;
            
            const current = formatTime(videoElement.currentTime);
            const duration = formatTime(videoElement.duration || 0);
            document.getElementById('time-display').textContent = `${current} / ${duration}`;
        }
        
        function updateProgress() {
            const progressText = document.getElementById('progress-text');
            const progressFill = document.getElementById('progress-fill');

            if (!progressText || !progressFill) {
                return;
            }

            if (!currentSegments.length) {
                progressText.textContent = 'No segments available';
                progressFill.style.width = '0%';
                return;
            }

            const total = currentSegments.length;
            const completed = currentSegments.reduce((count, segment) => count + (hasExpertDecision(segment) ? 1 : 0), 0);

            if (completed >= total) {
                progressText.textContent = `All ${total} segments completed`;
            } else {
                progressText.textContent = `Segment ${completed + 1} of ${total}`;
            }

            const percent = (completed / total) * 100;
            progressFill.style.width = `${percent}%`;
        }

        function showStatus(message, type) {
            const containers = [
                document.getElementById('global-status-messages'),
                document.getElementById('status-messages')
            ].filter(Boolean);

            if (containers.length === 0) {
                return;
            }

            containers.forEach(container => {
                const statusDiv = document.createElement('div');
                statusDiv.className = `status-message status-${type}`;
                statusDiv.textContent = message;
                container.appendChild(statusDiv);

                setTimeout(() => {
                    if (statusDiv.parentNode) {
                        statusDiv.parentNode.removeChild(statusDiv);
                    }
                }, 5000);
            });
        }
        
        function openAddQuestionModal() {
            if (!videoElement || !currentVideoId) {
                return;
            }

            // Pause the video and remember its state
            const wasPlaying = !videoElement.paused;
            videoElement.pause();
            
            // Store whether video was playing before modal opened
            videoElement.dataset.wasPlaying = wasPlaying;
            
            // Store the current timestamp
            manualQuestionTimestamp = videoElement.currentTime;
            
            // Update modal display
            const modal = document.getElementById('add-question-modal');
            const timestampInput = document.getElementById('manual-timestamp');
            
            if (timestampInput) {
                // Set the input value in time format (MM:SS or HH:MM:SS)
                timestampInput.value = formatSecondsToTimeString(manualQuestionTimestamp);
                
                // Add event listener for timestamp changes
                timestampInput.oninput = function() {
                    // Validate and update timestamp as user types
                    const seconds = parseTimeToSeconds(this.value);
                    manualQuestionTimestamp = seconds;
                };
            }
            
            // Reset form
            const form = document.getElementById('manual-question-form');
            if (form) {
                form.reset();
                // Restore the timestamp after reset
                if (timestampInput) {
                    timestampInput.value = formatSecondsToTimeString(manualQuestionTimestamp);
                }
            }
            
            // Clear feedback
            const feedback = document.getElementById('manual-form-feedback');
            if (feedback) {
                feedback.textContent = '';
            }
            
            // Show modal
            if (modal) {
                modal.classList.add('active');
            }
        }
        
        function closeAddQuestionModal() {
            const modal = document.getElementById('add-question-modal');
            if (modal) {
                modal.classList.remove('active');
            }
            
            // Resume video if it was playing before modal opened
            if (videoElement && videoElement.dataset.wasPlaying === 'true') {
                videoElement.play();
                delete videoElement.dataset.wasPlaying;
            }
            
            // Clear the stored timestamp
            manualQuestionTimestamp = null;
        }
        
        async function handleManualQuestionSubmit(event) {
            event.preventDefault();
            
            if (expertSaveInProgress) {
                return;
            }
            
            if (!currentVideoId) {
                setManualFormFeedback('Invalid state. Please try again.');
                return;
            }
            
            const timestampInput = document.getElementById('manual-timestamp');
            const typeSelect = document.getElementById('manual-question-type');
            const questionInput = document.getElementById('manual-question-text');
            const answerInput = document.getElementById('manual-answer-text');
            
            // Parse the timestamp from the time format input
            const timestampStr = timestampInput ? timestampInput.value.trim() : '';
            const timestamp = parseTimeToSeconds(timestampStr);
            
            const questionType = normalizeQuestionType(typeSelect ? typeSelect.value.trim() : '');
            const question = questionInput ? questionInput.value.trim() : '';
            const answer = answerInput ? answerInput.value.trim() : '';
            
            // Validate timestamp format
            if (!timestampStr || timestampStr === '') {
                setManualFormFeedback('Please enter a timestamp (e.g., 6:06 or 1:30:45).');
                timestampInput.focus();
                return;
            }
            
            // Validate timestamp is a valid time format
            if (!timestampStr.match(/^(?:(?:([0-9]+):)?([0-5]?[0-9]):)?([0-5]?[0-9])$/)) {
                setManualFormFeedback('Please enter a valid time format (MM:SS or HH:MM:SS).');
                timestampInput.focus();
                return;
            }
            
            // Validate timestamp is within video duration
            if (timestamp < 0 || (videoElement && timestamp > videoElement.duration)) {
                setManualFormFeedback(`Please enter a timestamp within the video duration (0:00 - ${formatSecondsToTimeString(videoElement.duration)}).`);
                timestampInput.focus();
                return;
            }
            
            // Validate all fields are filled
            if (!questionType || questionType === '') {
                setManualFormFeedback('Please select a question type.');
                typeSelect.focus();
                return;
            }
            
            if (!question || question === '') {
                setManualFormFeedback('Please enter a question.');
                questionInput.focus();
                return;
            }
            
            if (!answer || answer === '') {
                setManualFormFeedback('Please enter an answer.');
                answerInput.focus();
                return;
            }
            
            expertSaveInProgress = true;
            toggleManualFormState(true);
            setManualFormFeedback('Saving question...', 'success');
            
            // For manual questions, segmentStart and segmentEnd are the same as timestamp
            const segmentStart = timestamp;
            const segmentEnd = timestamp;
            
            const payload = {
                videoId: currentVideoId,
                segmentStart: segmentStart,
                segmentEnd: segmentEnd,
                timestamp: timestamp,
                questionType,
                question,
                answer,
                isManual: true // Flag to indicate this is a manually added question
            };
            
            try {
                const response = await fetch('/api/expert-questions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                
                if (!response.ok || !data.success) {
                    const errorMessage = data && data.message ? data.message : 'Failed to save question.';
                    throw new Error(errorMessage);
                }
                
                // Create a virtual segment for display
                const manualSegment = {
                    start: segmentStart,
                    end: segmentEnd,
                    isManual: true
                };
                
                setExpertQuestionForSegment(manualSegment, {
                    videoId: currentVideoId,
                    segmentStart: segmentStart,
                    segmentEnd: segmentEnd,
                    timestamp: timestamp,
                    questionType,
                    question,
                    answer,
                    isManual: true,
                    skipReason: '',
                    updatedAt: data.updatedAt || new Date().toISOString()
                });
                
                // Refresh the expert questions panel
                updateExpertQuestionsPanel(currentSegments[currentSegmentIndex]);
                
                closeAddQuestionModal();
                
            } catch (error) {
                console.error('Failed to save manual question:', error);
                setManualFormFeedback(error.message || 'Failed to save question.');
            } finally {
                expertSaveInProgress = false;
                toggleManualFormState(false);
            }
        }
        
        function setManualFormFeedback(message, type = 'error') {
            const feedback = document.getElementById('manual-form-feedback');
            if (!feedback) {
                return;
            }
            
            feedback.textContent = message || '';
            feedback.classList.remove('success');
            
            if (message && type === 'success') {
                feedback.classList.add('success');
            }
        }
        
        function toggleManualFormState(disabled) {
            const form = document.getElementById('manual-question-form');
            if (!form) {
                return;
            }
            
            Array.from(form.elements).forEach(element => {
                if (element.tagName === 'BUTTON' && element.type === 'button') {
                    // Don't disable the cancel button
                    return;
                }
                element.disabled = disabled;
            });
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '00:00';
            
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
        }
        
        // Helper function to parse time string (MM:SS or HH:MM:SS) to seconds
        function parseTimeToSeconds(timeStr) {
            if (!timeStr) return 0;
            
            // Clean the input
            timeStr = timeStr.trim();
            
            // Match formats like: 6:06, 06:06, 1:06:06
            const parts = timeStr.split(':').map(part => parseInt(part, 10) || 0);
            
            if (parts.length === 1) {
                // Just seconds
                return parts[0];
            } else if (parts.length === 2) {
                // MM:SS
                return parts[0] * 60 + parts[1];
            } else if (parts.length === 3) {
                // HH:MM:SS
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            
            return 0;
        }
        
        // Helper function to format seconds to time string for display
        function formatSecondsToTimeString(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            
            seconds = Math.floor(seconds);
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
        }
    </script>
</body>
</html>



