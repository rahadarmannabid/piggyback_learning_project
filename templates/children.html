<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Kids Videos | Piggyback</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Nunito", "Baloo 2", "Comic Sans MS", Arial, sans-serif;
      background: linear-gradient(180deg, #fef6ff 0%, #f2f9ff 45%, #ffffff 100%);
      margin: 0;
      min-height: 100vh;
      color: #1f2a3d;
      position: relative;
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      width: 200px;
      height: 200px;
      border-radius: 48% 52% 46% 54%;
      z-index: -2;
      filter: blur(0);
      opacity: 0.25;
    }

    body::before {
      top: -60px;
      left: -40px;
      background: #ffd870;
    }

    body::after {
      bottom: -80px;
      right: -40px;
      background: #7bd3ff;
    }

    .kids-page {
      width: min(1280px, 94%);
      margin: 0 auto 64px;
      padding-top: 28px;
      position: relative;
      z-index: 1;
    }

    .kids-top-bar {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 18px 28px;
      background: #ffffff;
      border-radius: 36px;
      box-shadow: 0 22px 45px rgba(33, 91, 182, 0.2);
      position: sticky;
      top: 20px;
      flex-wrap: wrap;
      row-gap: 14px;
      margin-bottom: 36px;
    }

    body.watching-video .kids-top-bar {
      position: static;
      top: auto;
      margin-bottom: 28px;
    }

    .kids-top-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .kids-top-bar>* {
      flex-shrink: 0;
    }

    .kids-avatar {
      width: 54px;
      height: 54px;
      border-radius: 50%;
      background: linear-gradient(135deg, #69d6ff, #5aa9ff);
      display: grid;
      place-items: center;
      color: #ffffff;
      font-size: 1.8rem;
      box-shadow: inset 0 5px 0 rgba(255, 255, 255, 0.55);
    }

    #back-button {
      display: none;
      border: none;
      border-radius: 999px;
      background: linear-gradient(135deg, #ff6d85, #ff378f);
      color: #ffffff;
      font-weight: 600;
      padding: 10px 20px;
      font-size: 0.95rem;
      cursor: pointer;
      box-shadow: 0 16px 32px rgba(255, 61, 124, 0.38);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    #back-button span {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    #back-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 20px 36px rgba(255, 61, 124, 0.45);
    }

    .kids-search {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 12px;
      background: #f0f5ff;
      border-radius: 999px;
      padding: 10px 16px;
      box-shadow: inset 0 0 0 2px rgba(112, 163, 255, 0.12);
    }

    .kids-search input {
      flex: 1;
      border: none;
      background: transparent;
      font-size: 1rem;
      letter-spacing: 0.01em;
      color: #214375;
      outline: none;
    }

    .kids-search input::placeholder {
      color: rgba(33, 67, 117, 0.55);
      font-weight: 600;
    }

    .kids-search button {
      border: none;
      background: linear-gradient(135deg, #5e7bff, #3a4dfd);
      color: #ffffff;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(56, 95, 255, 0.32);
      transition: transform 0.2s ease;
    }

    .kids-search button:hover {
      transform: translateY(-1px);
    }

    /* Grid for video cards */
    #video-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 32px;
      width: 100%;
      transition: grid-template-columns 0.2s ease;
    }

    .video-card {
      background: #ffffff;
      border-radius: 32px;
      padding: 18px 18px 24px;
      box-shadow: 0 28px 46px rgba(60, 113, 255, 0.18);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      position: relative;
      overflow: visible;
      cursor: pointer;
    }

    .video-card::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: 34px;
      background: linear-gradient(160deg, rgba(255, 197, 197, 0.6), rgba(192, 229, 255, 0.6));
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: -1;
    }

    .video-card:hover {
      transform: translateY(-6px) scale(1.02);
      box-shadow: 0 32px 50px rgba(56, 95, 255, 0.22);
    }

    .video-card:hover::after {
      opacity: 1;
    }

    .thumb-wrapper {
      position: relative;
      width: 100%;
      padding-top: 62%;
      border-radius: 24px;
      overflow: hidden;
      background: #dfe9ff;
      margin-bottom: 18px;
    }

    .video-thumb {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .video-duration {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.72);
      color: #ffffff;
      font-size: 0.8rem;
      font-weight: 700;
      padding: 4px 9px;
      border-radius: 999px;
      letter-spacing: 0.04em;
    }

    .video-info {
      padding: 0 10px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .video-title {
      font-size: 1.05rem;
      font-weight: 800;
      margin: 0;
      color: #2a3767;
      line-height: 1.3;
    }

    .video-empty {
      grid-column: 1 / -1;
      text-align: center;
      padding: 60px 20px;
      background: rgba(255, 255, 255, 0.65);
      border-radius: 32px;
      box-shadow: 0 20px 36px rgba(87, 128, 255, 0.15);
      font-size: 1.05rem;
      font-weight: 600;
      color: #6271a4;
    }

    /* Quiz player wrapper */
    #player-container {
      display: none;
      margin-top: 36px;
      width: 100%;
      flex-direction: column;
      gap: 24px;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 36px;
      padding: 32px;
      box-shadow: 0 32px 60px rgba(41, 86, 160, 0.18);
    }

    /* Video layout */
    #video-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0;
      width: 100%;
    }
    /* Video container */
    #video-container {
      position: relative;
      display: inline-block;
      width: 960px;
      max-width: 100%;
      border-radius: 24px;
      overflow: hidden;
      background: #000;
      transition: border-radius 0.2s ease;
    }

    #player {
      width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
      border-radius: 24px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      transition: border-radius 0.2s ease;
    }

    #player::-webkit-media-controls-fullscreen-button {
      display: none !important;
    }

    #player::-moz-fullscreen-button {
      display: none !important;
    }

    /* Question box overlay */
    #question-box {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 16;
      width: clamp(280px, 68%, 680px);
      max-width: calc(100% - 32px);
      background: none;
      align-items: flex-end;
      gap: 18px;
      pointer-events: none;
    }

    #question-box .question-character {
      width: clamp(120px, 24%, 190px);
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.35);
      box-shadow: 0 18px 38px rgba(14, 55, 120, 0.22);
      overflow: hidden;
      pointer-events: none;
    }

    #question-box .question-character video {
      width: 100%;
      display: block;
    }

    #question-box .question-bubble {
      position: relative;
      flex: 1;
      padding: 28px 32px;
      border-radius: 28px;
      background: rgba(255, 255, 255, 0.96);
      box-shadow: 0 32px 60px rgba(41, 86, 160, 0.18);
      pointer-events: auto;
    }

    #question-box .question-bubble::after {
      content: "";
      position: absolute;
      bottom: 22px;
      left: -22px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.96);
      transform: rotate(45deg);
      border-radius: 10px;
      box-shadow: -10px 12px 24px rgba(41, 86, 160, 0.16);
    }

    #question-box h3 {
      margin: 0;
      font-size: 1.6rem;
      font-weight: 700;
      color: #1f2a3d;
      text-align: left;
    }

    .question-actions {
      display: none;
      margin-top: 16px;
      gap: 12px;
      flex-wrap: wrap;
    }

    .question-actions button {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .question-actions button.retry-btn {
      background: linear-gradient(135deg, #5aa9ff, #69d6ff);
      color: #ffffff;
      box-shadow: 0 8px 18px rgba(90, 169, 255, 0.35);
    }

    .question-actions button.skip-btn {
      background: #ffffff;
      color: #1f2a3d;
      box-shadow: 0 6px 14px rgba(31, 42, 61, 0.15);
    }

    .question-actions button:focus-visible {
      outline: 3px solid rgba(90, 169, 255, 0.45);
      outline-offset: 2px;
    }

    .question-actions button:hover {
      transform: translateY(-1px);
    }

    .question-actions button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    #feedback {
      margin-top: 14px;
      font-weight: 600;
      font-size: 1.1rem;
      color: #356ae6;
      text-align: left;
    }

    #timestamp {
      margin-top: 10px;
      font-size: 1rem;
      color: #52607b;
      font-style: italic;
      text-align: left;
    }

    /* Transparent blocker */
    #blocker {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0);
      z-index: 15;
      display: none;
      pointer-events: auto;
    }

    /* Floating controls */
    .video-floating-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 10px;
      z-index: 20;
    }

    .video-floating-controls button {
      background: rgba(0, 119, 204, 0.9);
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: background 0.2s ease;
    }

    .video-floating-controls button:hover,
    .video-floating-controls button:focus-visible {
      background: rgba(0, 95, 163, 0.95);
      outline: none;
    }

    #fullscreen-toggle[aria-pressed="true"] {
      background: rgba(0, 95, 163, 0.95);
    }

    #video-container:fullscreen,
    #video-container:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      border-radius: 0;
    }

    #video-container:fullscreen #player,
    #video-container:-webkit-full-screen #player {
      border-radius: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    #video-container:fullscreen #question-box,
    #video-container:-webkit-full-screen #question-box {
      width: clamp(280px, 60vw, 720px);
      max-width: 80vw;
    }

    #video-container:fullscreen .video-floating-controls,
    #video-container:-webkit-full-screen .video-floating-controls {
      top: 20px;
      right: 20px;
    }

    .video-fullscreen-hitbox {
      position: absolute;
      bottom: 12px;
      right: 12px;
      width: 48px;
      height: 48px;
      z-index: 25;
      pointer-events: none;
    }

    #question-overlay {
      position: absolute;
      inset: 0;
      background: rgba(20, 32, 61, 0.55);
      backdrop-filter: blur(10px);
      display: none;
      opacity: 0;
      z-index: 12;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .video-fullscreen-hitbox button {
      pointer-events: auto;
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.45);
      color: #fff;
      font-size: 20px;
      display: grid;
      place-items: center;
      transition: background 0.2s ease;
    }

    .video-fullscreen-hitbox button:hover,
    .video-fullscreen-hitbox button:focus-visible {
      background: rgba(0, 0, 0, 0.6);
      outline: none;
    }

    .video-fullscreen-hitbox button .icon-exit {
      display: none;
    }

    body.fullscreen-active .video-fullscreen-hitbox button {
      background: rgba(0, 0, 0, 0.55);
    }

    body.fullscreen-active .video-fullscreen-hitbox button .icon-enter {
      display: none;
    }

    body.fullscreen-active .video-fullscreen-hitbox button .icon-exit {
      display: inline;
    }

    /* Sidebar (dev/testing) */
    #sidebar {
      width: 30%;
      border-left: 2px solid #ddd;
      padding: 15px;
      background: #f9f9f9;
      overflow-y: auto;
      max-height: 600px;
    }

    #sidebar h3 {
      margin-top: 0;
    }

    #sidebar ul {
      list-style: none;
      padding: 0;
    }

    #sidebar li {
      margin-bottom: 12px;
      font-size: 0.9em;
    }

    #sidebar a {
      color: #0077cc;
      text-decoration: none;
      cursor: pointer;
    }

    #sidebar a:hover {
      text-decoration: underline;
    }

    .hidden {
      display: none !important;
    }

    /* Responsive tweaks */
    @media (max-width: 1024px) {
      .kids-top-bar {
        gap: 16px;
        padding: 16px 22px;
        margin-bottom: 26px;
      }

      #question-box {
        width: clamp(280px, 82%, 560px);
      }

      #question-box .question-character {
        width: clamp(110px, 28%, 170px);
      }

      #question-box h3 {
        font-size: 1.45rem;
      }
    }

    @media (max-width: 900px) {
      .kids-top-bar {
        flex-direction: column;
        align-items: stretch;
        position: static;
        gap: 12px;
        margin-bottom: 28px;
      }

      .kids-top-left {
        width: 100%;
        justify-content: flex-start;
      }

      .kids-search {
        width: 100%;
        order: 2;
      }

      #video-grid {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 26px;
      }

      .video-card {
        padding: 16px 16px 22px;
        border-radius: 28px;
      }

      .thumb-wrapper {
        border-radius: 22px;
        margin-bottom: 16px;
      }

      #question-box {
        gap: 14px;
      }

      #question-box .question-bubble {
        padding: 24px 26px;
      }

      #question-box .question-bubble::after {
        bottom: 18px;
        left: -18px;
        width: 26px;
        height: 26px;
      }
    }

    @media (max-width: 700px) {
      .kids-page {
        width: 94%;
      }

      #video-wrapper {
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }

      #video-container {
        width: 100%;
      }

      #video-grid {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 22px;
      }

      .video-card {
        padding: 14px 14px 20px;
        border-radius: 26px;
      }

      .thumb-wrapper {
        padding-top: 58%;
      }

      .kids-top-bar {
        padding: 14px 18px;
        border-radius: 28px;
        margin-bottom: 24px;
      }

      .kids-avatar {
        width: 48px;
        height: 48px;
        font-size: 1.4rem;
      }

      #question-box {
        flex-direction: column-reverse;
        align-items: center;
        gap: 12px;
        width: clamp(260px, 92%, 360px);
      }

      #question-box .question-character {
        width: clamp(120px, 42%, 160px);
      }

      #question-box .question-bubble {
        padding: 22px 20px;
        text-align: center;
      }

      #question-box .question-bubble::after {
        bottom: -16px;
        left: 50%;
        transform: translateX(-50%) rotate(45deg);
        width: 28px;
        height: 28px;
        box-shadow: 0 14px 24px rgba(41, 86, 160, 0.16);
      }

      #question-box h3,
      #timestamp,
      #feedback {
        text-align: center;
      }
    }
  </style>
</head>

<body>
  <main class="kids-page">
    <header class="kids-top-bar">
      <div class="kids-top-left">
        <button id="back-button" type="button">
          <span aria-hidden="true">&#8592;</span>
          <span>Back to Library</span>
        </button>
        <div class="kids-avatar" aria-hidden="true">&#128100;</div>
      </div>
      <div class="kids-search" role="search">
        <input id="kids-search" type="search" placeholder="Search Piggyback Kids" aria-label="Search for a video">
        <button id="kids-search-btn" type="button" aria-label="Search">
          <span aria-hidden="true">&#128269;</span>
        </button>
      </div>
    </header>

    <!-- Video library -->
    <div id="video-grid"></div>

    <!-- Quiz Player -->
    <div id="player-container">
      <div id="video-wrapper">
        <!-- Video on the left -->
        <div id="video-container">
        <video id="player" controls playsinline controlslist="nodownload noremoteplayback"></video>
        <div id="question-overlay" aria-hidden="true"></div>
        <div id="blocker" aria-hidden="true"></div>
        <div id="question-box" role="dialog" aria-live="assertive" aria-labelledby="question" aria-describedby="timestamp feedback">
          <div class="question-character">
            <video src="/assets/asking_question.webm" autoplay loop muted playsinline></video>
          </div>
          <div class="question-bubble">
            <h3 id="question"></h3>
            <p id="timestamp"></p>
            <p id="feedback"></p>
            <div id="question-actions" class="question-actions">
              <button id="retry-answer-btn" class="retry-btn" type="button">Try again</button>
              <button id="skip-answer-btn" class="skip-btn" type="button">Skip for now</button>
            </div>
          </div>
        </div>
        <div class="video-floating-controls">
          <button id="toggle-sidebar" type="button" title="Toggle question list" aria-label="Toggle question list">&#128472;</button>
        </div>
        <div class="video-fullscreen-hitbox">
          <button id="custom-fullscreen-btn" type="button" aria-label="Toggle fullscreen">
            <span class="icon-enter">&#x26F6;</span>
            <span class="icon-exit">&#x2715;</span>
          </button>
        </div>
      </div>
    </div>

      <!-- Sidebar -->
      <div id="sidebar" class="hidden">
        <h3>&#128220; Questions</h3>
        <ul id="question-list"></ul>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <script>
    // ===============================
    // CONFIGURATION
    // ===============================
    const DEV_MODE = true; // set false to hide sidebar & toggle in production

    const THRESHOLDS = {
      phrase: { correct: 0.6, borderline: 0.5 },
      number: { correct: 0.7, borderline: 0.6 }
    };

    const TTS_DEFAULTS = {
      voice: "sage",
      speed: 0.9,
      format: "mp3"
    };

    const MIN_FEEDBACK_DISPLAY_MS = 1100;
    const LISTEN_RETRY_DELAY_MS = 1400;
    const MAX_LISTEN_RETRIES = 2;
    const SILENCE_THRESHOLD = 0.015;
    const SILENCE_DURATION_MS = 2000;
    const SPEECH_FRAMES_REQUIRED = 6;
    const VOICE_PRIORITY_PATTERNS = [
      /child/i,
      /kid/i,
      /young/i,
      /girl/i,
      /boy/i,
      /teen/i
    ];
    const ENGLISH_US_VOICE_PATTERN = /en\s*-?us/i;
    const VOICE_NAME_PREFERENCES = [
      /Jenny.*Neural/i,
      /Aria.*Neural/i,
      /Ana.*Neural/i,
      /Ava.*Neural/i,
      /Alyssa.*Neural/i,
      /Emma.*Neural/i,
      /Lia.*Neural/i,
      /Amber.*Neural/i,
      /Mia.*Neural/i,
      /Sara.*Neural/i,
      /Alloy/i,
      /Pippa/i,
      /Neural.*Child/i,
      /Natural.*Child/i,
      /Kid/i,
      /Children/i,
      /Young/i,
      /Girl/i,
      /Boy/i,
      /Google US English/i,
      /Google UK English Female/i,
      /Samantha/i
    ];
    const STORED_VOICE_KEY = "piggybackPreferredVoiceName";

    const SUCCESS_FEEDBACK = [
      "Good job!",
      "Amazing!",
      "Fantastic!",
      "Awesome work!",
      "You nailed it!"
    ];
    const BORDERLINE_FEEDBACK = [
      "Almost! Let's watch it again."
    ];
    const RETRY_FEEDBACK = "I think we missed it. Let's watch it again.";

    // ===============================
    // Global State
    // ===============================
    let segments = [];
    let asked = new Set();
    let checkInterval = null;
    let activeQuestion = false;
    let previousTime = 0;
    let maxAllowedTime = 0;
    let skipLockBypass = false;
    let totalQuestions = 0;
    let correctAnswers = 0;
    let libraryVideos = [];
    let questionUtterance = null;
    let questionSpeechCancelled = false;
    let feedbackUtterance = null;
    let currentListenAttempt = 0;
    let currentQuestionContext = null;
    let preferredSpeechVoice = null;

    function setQuestionOverlay(active) {
      if (!questionOverlay) return;
      if (active) {
        questionOverlay.style.display = "block";
        requestAnimationFrame(() => {
          questionOverlay.style.opacity = "1";
        });
      } else {
        questionOverlay.style.opacity = "0";
        setTimeout(() => {
          if (questionOverlay.style.opacity === "0") {
            questionOverlay.style.display = "none";
          }
        }, 200);
      }
    }

    function getStoredVoiceName() {
      if (typeof window === "undefined" || typeof window.localStorage === "undefined") {
        return null;
      }
      try {
        const stored = window.localStorage.getItem(STORED_VOICE_KEY);
        return stored && stored.trim() ? stored.trim() : null;
      } catch (err) {
        console.warn("Unable to access stored voice:", err);
        return null;
      }
    }

    function storePreferredVoiceName(name) {
      if (typeof window === "undefined" || typeof window.localStorage === "undefined") {
        return;
      }
      try {
        if (name && name.trim()) {
          window.localStorage.setItem(STORED_VOICE_KEY, name.trim());
        } else {
          window.localStorage.removeItem(STORED_VOICE_KEY);
        }
      } catch (err) {
        console.warn("Unable to persist preferred voice:", err);
      }
    }

    function selectPreferredVoiceFrom(voices) {
      if (!Array.isArray(voices) || voices.length === 0) {
        return null;
      }

      const storedName = getStoredVoiceName();
      if (storedName) {
        const storedMatch = voices.find(
          (voice) => voice?.name === storedName || voice?.voiceURI === storedName
        );
        if (storedMatch) {
          return storedMatch;
        }
      }

      for (const pattern of VOICE_NAME_PREFERENCES) {
        const match = voices.find(voice => pattern.test(`${voice?.name || ""} ${voice?.voiceURI || ""}`));
        if (match) {
          storePreferredVoiceName(match.name || match.voiceURI || "");
          return match;
        }
      }

      let bestVoice = null;
      let bestScore = -Infinity;
      voices.forEach((voice, index) => {
        const name = voice?.name || "";
        const lang = voice?.lang || "";
        const descriptor = `${name} ${lang}`;
        let score = 0;

        if (VOICE_PRIORITY_PATTERNS.some(pattern => pattern.test(descriptor))) {
          score += 100;
        }
        if (VOICE_NAME_PREFERENCES.some(pattern => pattern.test(descriptor))) {
          score += 80;
        }
        if (ENGLISH_US_VOICE_PATTERN.test(lang)) {
          score += 25;
        } else if (/en/i.test(lang)) {
          score += 10;
        }
        if (/(neural|natural|wavenet|premium|studio)/i.test(descriptor)) {
          score += 8;
        }
        if (voice.default) {
          score += 4;
        }
        if (/kid|child|young/i.test(descriptor)) {
          score += 6;
        }
        if (/female|girl|boy|soprano|alto/i.test(descriptor)) {
          score += 5;
        }
        score -= index * 0.05;

        if (score > bestScore) {
          bestScore = score;
          bestVoice = voice;
        }
      });
      if (bestVoice) {
        storePreferredVoiceName(bestVoice.name || bestVoice.voiceURI || "");
      }
      return bestVoice || voices[0];
    }

    function refreshPreferredVoice() {
      if (!("speechSynthesis" in window)) {
        return null;
      }
      const voices = window.speechSynthesis.getVoices();
      if (!voices || voices.length === 0) {
        return preferredSpeechVoice;
      }
      preferredSpeechVoice = selectPreferredVoiceFrom(voices);
      return preferredSpeechVoice;
    }

    function ensurePreferredVoice() {
      if (!("speechSynthesis" in window)) {
        return null;
      }
      if (preferredSpeechVoice) {
        return preferredSpeechVoice;
      }
      const voice = refreshPreferredVoice();
      if (voice) {
        return voice;
      }
      // Trigger async loading if voices are not ready yet.
      try {
        window.speechSynthesis.getVoices();
      } catch (err) {
        console.warn("Unable to prime speech voices:", err);
      }
      return preferredSpeechVoice;
    }

    if ("speechSynthesis" in window) {
      const synth = window.speechSynthesis;
      try {
        const handler = () => refreshPreferredVoice();
        if (typeof synth.addEventListener === "function") {
          synth.addEventListener("voiceschanged", handler);
        } else {
          synth.onvoiceschanged = handler;
        }
      } catch (err) {
        console.warn("Failed to attach voiceschanged listener:", err);
      }
      refreshPreferredVoice();
    }

    if (typeof window !== "undefined") {
      window.piggybackListVoices = () => {
        if (!("speechSynthesis" in window)) return [];
        return window.speechSynthesis.getVoices().map(v => ({
          name: v.name,
          lang: v.lang,
          default: v.default,
          voiceURI: v.voiceURI
        }));
      };
      window.piggybackSetPreferredVoice = (name) => {
        storePreferredVoiceName(name);
        refreshPreferredVoice();
      };
    }


    const player = document.getElementById("player");
    const videoContainer = document.getElementById("video-container");
    const fullscreenBtn = document.getElementById("custom-fullscreen-btn");
    const questionActionsEl = document.getElementById("question-actions");
    const retryAnswerBtn = document.getElementById("retry-answer-btn");
    const skipAnswerBtn = document.getElementById("skip-answer-btn");
    const questionOverlay = document.getElementById("question-overlay");
    hideQuestionActions();
    const fullscreenAPI = {
      element() {
        return document.fullscreenElement
          || document.webkitFullscreenElement
          || document.mozFullScreenElement
          || document.msFullscreenElement
          || null;
      },
      request(el) {
        if (!el) return Promise.reject(new Error("No element for fullscreen"));
        if (el.requestFullscreen) return el.requestFullscreen();
        if (el.webkitRequestFullscreen) {
          el.webkitRequestFullscreen();
          return Promise.resolve();
        }
        if (el.mozRequestFullScreen) {
          el.mozRequestFullScreen();
          return Promise.resolve();
        }
        if (el.msRequestFullscreen) {
          el.msRequestFullscreen();
          return Promise.resolve();
        }
        return Promise.reject(new Error("Fullscreen API not supported"));
      },
      exit() {
        if (document.exitFullscreen) return document.exitFullscreen();
        if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
          return Promise.resolve();
        }
        if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
          return Promise.resolve();
        }
        if (document.msExitFullscreen) {
          document.msExitFullscreen();
          return Promise.resolve();
        }
        return Promise.resolve();
      }
    };

    function hideQuestionActions(options = {}) {
      const { keepOverlay = false } = options;
      if (questionActionsEl) {
        questionActionsEl.style.display = "none";
      }
      if (retryAnswerBtn) {
        retryAnswerBtn.style.display = "none";
        retryAnswerBtn.disabled = false;
      }
      if (skipAnswerBtn) {
        skipAnswerBtn.style.display = "none";
        skipAnswerBtn.disabled = false;
      }
      if (!keepOverlay) {
        setQuestionOverlay(false);
      }
    }

    function showQuestionActions({ showRetry = true, showSkip = true } = {}) {
      if (!questionActionsEl) return;
      questionActionsEl.style.display = "flex";
      if (retryAnswerBtn) {
        retryAnswerBtn.style.display = showRetry ? "" : "none";
        retryAnswerBtn.disabled = false;
      }
      if (skipAnswerBtn) {
        skipAnswerBtn.style.display = showSkip ? "" : "none";
        skipAnswerBtn.disabled = false;
      }
      setQuestionOverlay(true);
    }

    function prepareManualRetry({ q, segStart, segEnd, message, color, showSkip = true }) {
      const feedbackEl = document.getElementById("feedback");
      if (message) {
        feedbackEl.innerText = message;
      }
      if (color) {
        feedbackEl.style.color = color;
      }
      currentQuestionContext = { q, segStart, segEnd };
      showQuestionActions({ showRetry: true, showSkip });
    }

    function updateFullscreenToggleState() {
      if (!fullscreenBtn) return;
      const active = fullscreenAPI.element() === videoContainer;
      fullscreenBtn.setAttribute("aria-pressed", active ? "true" : "false");
    }

    function toggleFullscreen() {
      const current = fullscreenAPI.element();
      if (current === videoContainer) {
        const exitResult = fullscreenAPI.exit();
        if (exitResult && typeof exitResult.then === "function") {
          exitResult.then(updateFullscreenToggleState).catch(err => console.warn("Exit fullscreen failed:", err));
        } else {
          setTimeout(updateFullscreenToggleState, 0);
        }
        return;
      }

      const requestResult = fullscreenAPI.request(videoContainer);
      if (requestResult && typeof requestResult.then === "function") {
        requestResult.then(updateFullscreenToggleState).catch(err => console.warn("Fullscreen request failed:", err));
      } else {
        setTimeout(updateFullscreenToggleState, 0);
      }
    }

    function handleFullscreenChange() {
      const current = fullscreenAPI.element();
      const isContainerFullscreen = current === videoContainer;
      document.body.classList.toggle("fullscreen-active", isContainerFullscreen);
      updateFullscreenToggleState();
    }

    ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"]
      .forEach(evt => document.addEventListener(evt, handleFullscreenChange));

    if (retryAnswerBtn) {
      retryAnswerBtn.addEventListener("click", () => {
        if (!currentQuestionContext) return;
        hideQuestionActions();
        const feedbackEl = document.getElementById("feedback");
        feedbackEl.innerText = "Listening...";
        feedbackEl.style.color = "#384b87";
        currentListenAttempt = 0;
        startListening(
          currentQuestionContext.q,
          currentQuestionContext.segStart,
          currentQuestionContext.segEnd,
          0
        );
      });
    }

    if (skipAnswerBtn) {
      skipAnswerBtn.addEventListener("click", () => {
        hideQuestionActions();
        if (currentQuestionContext) {
          player.currentTime = currentQuestionContext.segStart;
        }
        resumeVideo();
      });
    }

    fullscreenBtn?.addEventListener("click", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      toggleFullscreen();
    });

    player.addEventListener("dblclick", (evt) => {
      evt.preventDefault();
      toggleFullscreen();
    });

    player.addEventListener("keydown", (evt) => {
      const key = typeof evt.key === "string" ? evt.key.toLowerCase() : "";
      if (key === "f") {
        evt.preventDefault();
        toggleFullscreen();
      }
    });
    // If anything triggers play while a question is active, immediately pause again
    player.addEventListener("play", (e) => {
      if (activeQuestion) {
        e.preventDefault?.();
        player.pause();
      }
    });

    // Prevent keyboard shortcuts (space, k, media keys) during questions
    document.addEventListener("keydown", (e) => {
      if (!activeQuestion) return;
      const k = e.key.toLowerCase();
      if (k === " " || k === "k" || k === "mediaplaypause") {
        e.preventDefault();
        e.stopPropagation();
      }
    }, { capture: true });

    const sidebar = document.getElementById("sidebar");
    const toggleBtn = document.getElementById("toggle-sidebar");
    const videoGrid = document.getElementById("video-grid");
    const backButton = document.getElementById("back-button");
    const searchInput = document.getElementById("kids-search");
    const searchButton = document.getElementById("kids-search-btn");

    // DEV mode visibility
    if (!DEV_MODE) {
      sidebar.classList.add("hidden");
      toggleBtn.classList.add("hidden");
    }

    // Sidebar toggle (single source of truth via .hidden class)
    toggleBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      sidebar.classList.toggle("hidden");
    });

    function renderVideoGrid(videos) {
      videoGrid.innerHTML = "";
      if (!videos || !videos.length) {
        videoGrid.innerHTML = `<div class="video-empty">No videos found. Try a different search!</div>`;
        return;
      }

      videos.forEach(video => {
        const card = document.createElement("div");
        card.className = "video-card";
        const safeTitle = video.title || "Untitled Video";
        const durationLabel = video.duration && video.duration !== "00:00" ? video.duration : "";
        card.innerHTML = `
          <div class="thumb-wrapper">
            <img class="video-thumb" src="${video.thumbnail}" alt="${safeTitle}">
            ${durationLabel ? `<span class="video-duration">${durationLabel}</span>` : ""}
          </div>
          <div class="video-info">
            <p class="video-title">${safeTitle}</p>
          </div>
        `;
        card.onclick = () => startQuiz(video);
        card.setAttribute("tabindex", "0");
        card.addEventListener("keydown", (evt) => {
          if (evt.key === "Enter" || evt.key === " ") {
            evt.preventDefault();
            startQuiz(video);
          }
        });
        videoGrid.appendChild(card);
      });
    }

    function applyFilters() {
      if (!Array.isArray(libraryVideos)) return;
      const searchTerm = (searchInput?.value || "").trim().toLowerCase();
      let filtered = [...libraryVideos];
      if (searchTerm) {
        filtered = filtered.filter(video => (video.title || "").toLowerCase().includes(searchTerm));
      }
      renderVideoGrid(filtered);
    }

    searchInput?.addEventListener("input", () => applyFilters());

    searchInput?.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        applyFilters();
      }
    });

    searchButton?.addEventListener("click", () => {
      searchInput?.focus();
      applyFilters();
    });

    // ===============================
    // Load Videos for Library
    // ===============================
    async function loadVideos() {
      try {
        const res = await fetch("/api/kids_videos?nocache=" + Date.now());
        const data = await res.json();
        if (!data.success) throw new Error("API error");

        libraryVideos = Array.isArray(data.videos) ? data.videos : [];
        applyFilters();
      } catch (err) {
        console.error("[Error] loading kids_videos:", err);
        videoGrid.innerHTML = '<div class="video-empty">Oops! We couldn\'t load the videos right now.</div>';
      }
    }

    // ===============================
    // Start Quiz for Selected Video
    // ===============================
    function startQuiz(video) {
      // Hide library, show quiz player
      videoGrid.style.display = "none";
      document.getElementById("player-container").style.display = "flex";
      backButton.style.display = "inline-flex";
      document.body.classList.add("watching-video");


      // Load video file
      player.src = video.local_path;
      player.play();

      asked.clear();
      previousTime = 0;
      maxAllowedTime = 0;
      skipLockBypass = false;

      // Load matching questions
      fetch(`/api/final-questions/${encodeURIComponent(video.video_id)}?nocache=${Date.now()}`)
        .then(res => res.json())
        .then(data => {
          if (!data.success) throw new Error(data.error || "Missing final questions");

          const entries = Array.isArray(data.segments) ? data.segments : [];
          segments = entries
            .map((seg, idx) => {
              const startSec = normalizeToSeconds(seg.segment_range_start);
              const endSec = normalizeToSeconds(seg.segment_range_end);
              const questionText = (seg.question || "").trim();
              const answerText = (seg.answer || "").trim();
              if (!questionText || !answerText) return null;
              const rawTrigger = endSec > 0 ? endSec : startSec;
              const triggerSec = Math.max(0, Math.round(rawTrigger));
              return {
                id: `segment_${idx + 1}`,
                index: idx,
                segment_start: startSec,
                segment_end: endSec,
                trigger_sec: triggerSec,
                ques_time: secondsToTimestamp(triggerSec),
                question: questionText,
                answer: answerText
              };
            })
            .filter(Boolean)
            .sort((a, b) => a.trigger_sec - b.trigger_sec);

          totalQuestions = segments.length;
          correctAnswers = 0;
          updateProgress();

          if (!segments.length) {
            throw new Error("No eligible questions found in final_questions.json");
          }

          populateSidebar();
          startMonitoring();
        })
        .catch(err => {
          console.error("[Error] Failed to load questions:", err);
          alert("Oops! We couldn't find any questions for this video yet.");
          document.body.classList.remove("watching-video");
          document.getElementById("player-container").style.display = "none";
          videoGrid.style.display = "grid";
          backButton.style.display = "none";
        });
    }

    // ===============================
    // Monitor Video Playback
    // ===============================
    function startMonitoring() {
      clearInterval(checkInterval);
      checkInterval = setInterval(() => {
        let currentTime = Math.floor(player.currentTime);

        // --- Skip-lock ---
        if (!skipLockBypass && currentTime > maxAllowedTime + 2) {
          console.warn("Skip attempt detected!");
          player.currentTime = maxAllowedTime;
          return;
        }
        skipLockBypass = false;
        if (currentTime > maxAllowedTime) maxAllowedTime = currentTime;

        if (activeQuestion) {
          previousTime = currentTime;
          return;
        }

        // --- Question Triggers ---
        for (const segment of segments) {
          const segStart = segment.segment_start || 0;
          const segEnd = segment.segment_end && segment.segment_end > segStart
            ? segment.segment_end
            : segStart + 0.1;
          const trigger = segment.trigger_sec;

          if (previousTime < trigger && currentTime >= trigger && !asked.has(trigger)) {
            askQuestion(segment, segStart, segEnd);
            previousTime = currentTime;
            return;
          }
        }

        previousTime = currentTime;
      }, 700);
    }

    // ===============================
    // Speech Helpers
    // ===============================
    const ttsPlayback = {
      question: { audio: null, resolve: null, reject: null },
      feedback: { audio: null, resolve: null, reject: null }
    };

    function cleanupAudioChannel(channel) {
      const entry = ttsPlayback[channel];
      if (!entry) return;
      const audio = entry.audio;
      if (audio) {
        audio.onended = null;
        audio.onerror = null;
      }
      entry.audio = null;
      entry.resolve = null;
      entry.reject = null;
    }

    function stopAudioChannel(channel, options = {}) {
      const { markCancelled = false, markQuestionCancelledFlag = false } = options;
      const entry = ttsPlayback[channel];
      if (!entry || !entry.audio) {
        if (markQuestionCancelledFlag && channel === "question") {
          questionSpeechCancelled = true;
        }
        return;
      }
      const { audio, resolve } = entry;
      audio.onended = null;
      audio.onerror = null;
      try {
        audio.pause();
      } catch (err) {
        console.warn("Failed to pause audio:", err);
      }
      try {
        audio.src = "";
      } catch (err) {
        console.warn("Failed to reset audio source:", err);
      }
      cleanupAudioChannel(channel);
      if (markCancelled && typeof resolve === "function") {
        resolve({ cancelled: true });
      }
      if (markQuestionCancelledFlag && channel === "question") {
        questionSpeechCancelled = true;
      }
    }

    function stopSpeechSynthesisUtterances({ markQuestionCancelled = false } = {}) {
      if (markQuestionCancelled) {
        questionSpeechCancelled = true;
      }
      if ("speechSynthesis" in window) {
        try {
          window.speechSynthesis.cancel();
        } catch (err) {
          console.warn("Failed to cancel speech synthesis:", err);
        }
      }
      questionUtterance = null;
      feedbackUtterance = null;
    }

    async function requestTTS(text) {
      const trimmed = text?.trim();
      if (!trimmed) {
        throw new Error("No text provided for TTS.");
      }
      const res = await fetch("/api/tts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          text: trimmed,
          voice: TTS_DEFAULTS.voice,
          speed: TTS_DEFAULTS.speed,
          format: TTS_DEFAULTS.format
        })
      });
      let data = null;
      try {
        data = await res.json();
      } catch (err) {
        if (!res.ok) {
          throw new Error(`TTS request failed with status ${res.status}`);
        }
        throw new Error("TTS response was not valid JSON.");
      }
      if (!res.ok) {
        const message = data?.message || data?.detail || `status ${res.status}`;
        throw new Error(`TTS request failed: ${message}`);
      }
      if (!data?.success || !data?.audio) {
        throw new Error(data?.message || "TTS response missing audio.");
      }
      return {
        format: data.format || "mp3",
        audio: data.audio
      };
    }

    async function playTTSChannel(channel, text) {
      const { format, audio } = await requestTTS(text);
      const audioElement = new Audio(`data:audio/${format};base64,${audio}`);
      audioElement.preload = "auto";
      audioElement.crossOrigin = "anonymous";

      cleanupAudioChannel(channel);
      return new Promise((resolve, reject) => {
        ttsPlayback[channel].audio = audioElement;
        ttsPlayback[channel].resolve = resolve;
        ttsPlayback[channel].reject = reject;

        audioElement.onended = () => {
          cleanupAudioChannel(channel);
          resolve({ cancelled: false });
        };
        audioElement.onerror = (event) => {
          console.warn("Audio playback error:", event);
          cleanupAudioChannel(channel);
          reject(new Error("Audio playback failed."));
        };

        try {
          const playPromise = audioElement.play();
          if (playPromise && typeof playPromise.then === "function") {
            playPromise.catch(err => {
              cleanupAudioChannel(channel);
              reject(err);
            });
          }
        } catch (err) {
          cleanupAudioChannel(channel);
          reject(err);
        }
      });
    }

    function speakViaSpeechSynthesis(text, channel) {
      return new Promise((resolve) => {
        if (!("speechSynthesis" in window)) {
          resolve({ cancelled: false, error: true });
          return;
        }

        try {
          window.speechSynthesis.cancel();
        } catch (err) {
          console.warn("Failed to reset speech synthesis:", err);
        }

        const utterance = new SpeechSynthesisUtterance(text);
        const voice = ensurePreferredVoice();
        if (voice) {
          utterance.voice = voice;
          if (voice.lang) {
            utterance.lang = voice.lang;
          }
        } else {
          utterance.lang = "en-US";
        }

        const descriptor = voice ? `${voice.name || ""} ${voice.voiceURI || ""}` : "";
        const isLikelyMale = /male|man|boy/i.test(descriptor);
        const isLikelyKid = /kid|child|young/i.test(descriptor);
        const targetRate = channel === "question"
          ? (isLikelyKid ? 1.02 : 1.05)
          : (isLikelyKid ? 1.0 : 1.03);
        const targetPitch = channel === "question"
          ? (isLikelyMale ? 1.32 : 1.22)
          : (isLikelyMale ? 1.28 : 1.18);

        utterance.rate = targetRate;
        utterance.pitch = targetPitch;
        utterance.volume = 0.95;

        utterance.onend = () => {
          if (channel === "question") {
            const wasCancelled = questionSpeechCancelled;
            questionUtterance = null;
            questionSpeechCancelled = false;
            resolve({ cancelled: wasCancelled });
          } else {
            feedbackUtterance = null;
            resolve({ cancelled: false });
          }
        };

        utterance.onerror = (event) => {
          console.warn("Speech synthesis error:", event);
          if (channel === "question") {
            questionUtterance = null;
            resolve({ cancelled: questionSpeechCancelled, error: true });
          } else {
            feedbackUtterance = null;
            resolve({ cancelled: false, error: true });
          }
        };

        if (channel === "question") {
          questionUtterance = utterance;
        } else {
          feedbackUtterance = utterance;
        }

        try {
          window.speechSynthesis.speak(utterance);
        } catch (err) {
          console.warn("Unable to speak via speech synthesis:", err);
          if (channel === "question") {
            questionUtterance = null;
            resolve({ cancelled: questionSpeechCancelled, error: true });
          } else {
            feedbackUtterance = null;
            resolve({ cancelled: false, error: true });
          }
        }
      });
    }

    function cancelQuestionSpeech() {
      stopAudioChannel("question", { markCancelled: true, markQuestionCancelledFlag: true });
      stopAudioChannel("feedback", { markCancelled: true });
      stopSpeechSynthesisUtterances({ markQuestionCancelled: true });
    }

    async function speakQuestionText(text) {
      const trimmed = text?.trim();
      if (!trimmed) {
        return true;
      }

      stopAudioChannel("question", { markCancelled: true });
      stopSpeechSynthesisUtterances();
      questionSpeechCancelled = false;

      try {
        const result = await playTTSChannel("question", trimmed);
        return !result?.cancelled && !questionSpeechCancelled;
      } catch (err) {
        console.warn("OpenAI TTS failed for question speech:", err);
        const fallbackResult = await speakViaSpeechSynthesis(trimmed, "question");
        if (fallbackResult?.error) {
          return !questionSpeechCancelled;
        }
        return !fallbackResult?.cancelled;
      }
    }

    // ===============================
    // Feedback Helpers
    // ===============================
    function pickRandomCelebration() {
      if (!Array.isArray(SUCCESS_FEEDBACK) || SUCCESS_FEEDBACK.length === 0) {
        return "Great job!";
      }
      const index = Math.floor(Math.random() * SUCCESS_FEEDBACK.length);
      return SUCCESS_FEEDBACK[index];
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, Math.max(0, ms || 0)));
    }

    async function speakFeedbackText(text) {
      const trimmed = text?.trim();
      if (!trimmed) {
        return;
      }
      stopAudioChannel("feedback", { markCancelled: true });
      stopSpeechSynthesisUtterances();
      try {
        await playTTSChannel("feedback", trimmed);
      } catch (err) {
        console.warn("OpenAI TTS failed for feedback speech:", err);
        await speakViaSpeechSynthesis(trimmed, "feedback");
      }
    }

    async function deliverFeedback({ message, color, confetti: launchConfetti = false, minVisibleMs = MIN_FEEDBACK_DISPLAY_MS }) {
      const feedbackEl = document.getElementById("feedback");
      feedbackEl.innerText = message;
      feedbackEl.style.color = color;

      if (launchConfetti) {
        fireConfettiBurst();
      }

      const start = Date.now();
      await speakFeedbackText(message);

      const elapsed = Date.now() - start;
      if (elapsed < minVisibleMs) {
        await wait(minVisibleMs - elapsed);
      }
    }

    function fireConfettiBurst() {
      if (typeof confetti !== "function") {
        return;
      }

      const duration = 1500;
      const animationEnd = Date.now() + duration;
      const colors = ["#5aa9ff", "#ffd870", "#9cf077", "#ff6d85"];

      (function frame() {
        confetti({
          particleCount: 7,
          startVelocity: 35,
          spread: 60,
          ticks: 90,
          gravity: 0.9,
          scalar: 1.1,
          origin: { x: Math.random() * 0.6 + 0.2, y: Math.random() * 0.2 + 0.6 },
          colors
        });

        if (Date.now() < animationEnd) {
          requestAnimationFrame(frame);
        }
      })();
    }

    // ===============================
    // Asking + Answering Questions
    // ===============================
    function askQuestion(q, segStart, segEnd) {
      activeQuestion = true;
      lockVideoControls();
      player.pause();

      currentQuestionContext = { q, segStart, segEnd };
      currentListenAttempt = 0;
      hideQuestionActions();

      document.getElementById("question-box").style.display = "flex";
      document.getElementById("question").innerText = q.question;
      document.getElementById("timestamp").innerHTML =
        `Appears at <a onclick="seekWithBypass(${toSeconds(q.ques_time)})">${q.ques_time}</a>`;
      const feedbackEl = document.getElementById("feedback");
      feedbackEl.innerText = "Let me read the question for you...";
      feedbackEl.style.color = "#384b87";
      setQuestionOverlay(true);
      speakQuestionText(q.question)
        .then(shouldContinue => {
          if (!shouldContinue) {
            return;
          }
          feedbackEl.innerText = "Listening...";
          feedbackEl.style.color = "#384b87";
          startListening(q, segStart, segEnd, 0);
        })
        .catch(err => {
          console.warn("Unable to speak question via TTS:", err);
          feedbackEl.innerText = "Listening...";
          feedbackEl.style.color = "#384b87";
          startListening(q, segStart, segEnd, 0);
        });
    }

    // ===============================
    // Whisper Recording + Transcription
    // ===============================
    async function startListening(q, segStart, segEnd, attempt = 0) {
      const feedbackEl = document.getElementById("feedback");
      currentListenAttempt = attempt;
      currentQuestionContext = { q, segStart, segEnd };
      hideQuestionActions({ keepOverlay: true });

      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        console.error("Mic access denied or unavailable:", err);
        return handleListeningFailure(q, segStart, segEnd, attempt, {
          message: "I can't hear you. Please allow the microphone so we can answer together.",
          color: "#ef4444",
          autoRetry: false,
          showSkip: true
        });
      }

      let recorder;
      try {
        recorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" });
      } catch (err) {
        console.error("MediaRecorder setup failed:", err);
        stream.getTracks().forEach(track => track.stop());
        return handleListeningFailure(q, segStart, segEnd, attempt, {
          message: "Hmm, I couldn't start listening. Let's try again when you're ready.",
          color: "#ef4444",
          autoRetry: attempt < 1,
          showSkip: true
        });
      }

      let chunks = [];
      let audioContext = null;
      let analyser = null;
      let analyserData = null;
      let silenceMonitorId = null;
      let silenceStart = null;
      let recognizedSpeech = false;
      let speechFrameCount = 0;
      let stopRequested = false;
      let autoStopTimeout = null;

      const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
      if (AudioContextCtor) {
        try {
          audioContext = new AudioContextCtor();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          analyser.smoothingTimeConstant = 0.8;
          analyserData = new Float32Array(analyser.fftSize);
          const sourceNode = audioContext.createMediaStreamSource(stream);
          sourceNode.connect(analyser);
        } catch (err) {
          console.warn("Silence detection unavailable:", err);
          audioContext = null;
          analyser = null;
          analyserData = null;
        }
      }

      const cancelSilenceMonitor = () => {
        if (silenceMonitorId) {
          cancelAnimationFrame(silenceMonitorId);
          silenceMonitorId = null;
        }
      };

      const cleanupAudioResources = async () => {
        cancelSilenceMonitor();
        if (audioContext && audioContext.state !== "closed") {
          try {
            await audioContext.close();
          } catch (err) {
            console.warn("Failed to close audio context:", err);
          }
        }
        audioContext = null;
        analyser = null;
        analyserData = null;
      };

      const requestStop = (reason) => {
        if (stopRequested) return;
        stopRequested = true;
        if (autoStopTimeout) {
          clearTimeout(autoStopTimeout);
          autoStopTimeout = null;
        }
        cancelSilenceMonitor();
        if (recorder && recorder.state === "recording") {
          console.log("Stopping recorder:", reason);
          try {
            recorder.stop();
          } catch (err) {
            console.warn("Recorder stop failed:", err);
          }
        }
      };

      // Monitor microphone volume to detect when the child stops speaking.
      const monitorSilence = () => {
        if (!analyser || stopRequested) return;

        analyser.getFloatTimeDomainData(analyserData);
        let sumSquares = 0;
        for (let i = 0; i < analyserData.length; i++) {
          const value = analyserData[i];
          sumSquares += value * value;
        }
        const rms = Math.sqrt(sumSquares / analyserData.length);

        if (rms > SILENCE_THRESHOLD) {
          if (speechFrameCount < SPEECH_FRAMES_REQUIRED) {
            speechFrameCount++;
            if (speechFrameCount >= SPEECH_FRAMES_REQUIRED) {
              recognizedSpeech = true;
            }
          }
          silenceStart = null;
        } else {
          if (speechFrameCount > 0) {
            speechFrameCount = Math.max(0, speechFrameCount - 1);
          }
          if (recognizedSpeech) {
            if (silenceStart === null) {
              silenceStart = performance.now();
            } else if (performance.now() - silenceStart >= SILENCE_DURATION_MS) {
              console.log("Auto-stopping recorder after silence gap");
              requestStop("silence");
              return;
            }
          }
        }

        silenceMonitorId = requestAnimationFrame(monitorSilence);
      };

      const startSilenceMonitor = () => {
        if (!analyser) return;
        silenceStart = null;
        speechFrameCount = 0;
        recognizedSpeech = false;
        cancelSilenceMonitor();
        silenceMonitorId = requestAnimationFrame(monitorSilence);
      };

      recorder.onstart = () => {
        feedbackEl.innerText = "Listening...";
        feedbackEl.style.color = "#384b87";
        stopRequested = false;
        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume().catch(err => console.warn("Audio context resume failed:", err));
        }
        startSilenceMonitor();
        autoStopTimeout = setTimeout(() => {
          console.log("Auto-stopping recorder after max duration");
          requestStop("timeout");
        }, 12000);
      };

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) chunks.push(e.data);
      };

      recorder.onstop = async () => {
        stopRequested = true;
        if (autoStopTimeout) {
          clearTimeout(autoStopTimeout);
          autoStopTimeout = null;
        }
        await cleanupAudioResources();
        stream.getTracks().forEach(track => track.stop());

        if (!chunks.length) {
          return handleListeningFailure(q, segStart, segEnd, attempt, {
            message: "I didn't hear anything, let's try again!",
            color: "#d97706",
            autoRetry: true,
            showSkip: true
          });
        }

        const blob = new Blob(chunks, { type: "audio/webm" });
        const formData = new FormData();
        formData.append("file", blob, "speech.webm");

        try {
          const res = await fetch("/api/transcribe", {
            method: "POST",
            body: formData
          });
          const data = await res.json();
          if (data.success && data.text.trim()) {
            feedbackEl.innerText = `You said: "${data.text.trim()}"`;
            feedbackEl.style.color = "#384b87";
            await processAnswer(data.text.trim().toLowerCase(), q, segStart, segEnd);
            return;
          } else {
            return handleListeningFailure(q, segStart, segEnd, attempt, {
              message: "I didn't hear anything, let's try again!",
              color: "#d97706",
              autoRetry: true,
              showSkip: true
            });
          }
        } catch (err) {
          console.error("[Error] Whisper error:", err);
          return handleListeningFailure(q, segStart, segEnd, attempt, {
            message: "Oops, I couldn't process that. Let's give it another try.",
            color: "#ef4444",
            autoRetry: attempt < 1,
            showSkip: true
          });
        }
      };

      try {
        recorder.start();
      } catch (err) {
        console.error("Failed to start recorder:", err);
        await cleanupAudioResources();
        stream.getTracks().forEach(track => track.stop());
        return handleListeningFailure(q, segStart, segEnd, attempt, {
          message: "Hmm, I couldn't start listening. Let's try again when you're ready.",
          color: "#ef4444",
          autoRetry: attempt < 1,
          showSkip: true
        });
      }
    }

    async function handleListeningFailure(q, segStart, segEnd, attempt, options = {}) {
      const {
        message,
        color = "#d97706",
        autoRetry = true,
        showSkip = true,
        delayMs = LISTEN_RETRY_DELAY_MS,
        fallbackMessage
      } = options;

      const feedbackEl = document.getElementById("feedback");
      if (message) {
        feedbackEl.innerText = message;
      }
      feedbackEl.style.color = color;

      currentQuestionContext = { q, segStart, segEnd };
      hideQuestionActions();
      const nextAttempt = attempt + 1;

      if (autoRetry && nextAttempt <= MAX_LISTEN_RETRIES) {
        await wait(delayMs);
        return startListening(q, segStart, segEnd, nextAttempt);
      }

      prepareManualRetry({
        q,
        segStart,
        segEnd,
        message: fallbackMessage || "",
        color,
        showSkip
      });
    }

    async function processAnswer(spoken, q, segStart, segEnd) {
      const quesSec = toSeconds(q.ques_time);
      const askedInSegment = Array.from(asked).filter(t => t >= segStart && t <= segEnd);

      console.log("Heard (final):", spoken, " | Expected:", q.answer);

      try {
        const response = await fetch("/api/check_answer", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ expected: q.answer, user: spoken })
        });
        const data = await response.json();
        console.log("Local check response:", data);

        const sim = parseFloat(data.similarity);
        const t = data.is_numeric ? THRESHOLDS.number : THRESHOLDS.phrase;

        if (sim >= t.correct) {
          const celebrationMessage = pickRandomCelebration();
          asked.add(quesSec);

          correctAnswers++;
          updateProgress();

          await deliverFeedback({
            message: celebrationMessage,
            color: "#22c55e",
            confetti: true,
            minVisibleMs: MIN_FEEDBACK_DISPLAY_MS + 200
          });

          await wait(200);
          resumeVideo();
          return;
        }

        const rewindTo = askedInSegment.length > 0
          ? Math.max(...askedInSegment) + 1
          : segStart;

        if (sim >= t.borderline) {
          const almostMessage = BORDERLINE_FEEDBACK[0] || "Almost! Let's watch it again.";

          await deliverFeedback({
            message: almostMessage,
            color: "#d97706",
            minVisibleMs: MIN_FEEDBACK_DISPLAY_MS
          });

          player.currentTime = rewindTo;
          await wait(200);
          resumeVideo();
          return;
        }

        await deliverFeedback({
          message: RETRY_FEEDBACK,
          color: "#ef4444",
          minVisibleMs: MIN_FEEDBACK_DISPLAY_MS
        });

        player.currentTime = rewindTo;
        await wait(200);
        resumeVideo();
      } catch (err) {
        console.error("[Warning] Answer check failed:", err);
        document.getElementById("feedback").innerText = "[Warning] Could not check answer.";
        setTimeout(resumeVideo, 1000);
      }
    }

    function resumeVideo() {
      activeQuestion = false;
      cancelQuestionSpeech();
      const box = document.getElementById("question-box");
      box.style.display = "none"; // hide overlay
      document.getElementById("feedback").innerText = ""; // clear feedback
      hideQuestionActions();
      currentQuestionContext = null;
      currentListenAttempt = 0;
      unlockVideoControls();          // unlock here
      player.play();
    }

    // ===============================
    // Sidebar Helpers
    // ===============================
    function populateSidebar() {
      const list = document.getElementById("question-list");
      list.innerHTML = "";
      segments.forEach((segment, idx) => {
        const label = segment.id || `segment_${idx + 1}`;
        const li = document.createElement("li");
        li.innerHTML = `
        <strong>${label}</strong> -
        <a onclick="seekWithBypass(${segment.trigger_sec})">${segment.ques_time}</a>
        <br>${segment.question}
      `;
        list.appendChild(li);
      });
    }
    function seekWithBypass(seconds) {
      skipLockBypass = true;
      player.currentTime = seconds;
    }

    // ===============================
    // Back Button
    // ===============================
    backButton.onclick = () => {
      player.pause();
      clearInterval(checkInterval);
      document.getElementById("player-container").style.display = "none";
      videoGrid.style.display = "grid";
      backButton.style.display = "none";
      document.body.classList.remove("watching-video");
    };

    // ===============================
    // Helpers
    // ===============================
    function normalizeToSeconds(value) {
      if (value === null || value === undefined) return 0;
      if (typeof value === "number" && !Number.isNaN(value)) return Math.max(0, value);
      if (typeof value === "string") {
        const trimmed = value.trim();
        if (!trimmed) return 0;
        if (trimmed.includes(":")) {
          const parts = trimmed.split(":").map(Number).filter(n => !Number.isNaN(n));
          if (parts.length === 3) return Math.max(0, parts[0] * 3600 + parts[1] * 60 + parts[2]);
          if (parts.length === 2) return Math.max(0, parts[0] * 60 + parts[1]);
          if (parts.length === 1) return Math.max(0, parts[0]);
        }
        const numeric = parseFloat(trimmed);
        if (!Number.isNaN(numeric)) return Math.max(0, numeric);
      }
      return 0;
    }

    function secondsToTimestamp(sec) {
      if (!sec || !Number.isFinite(sec)) return "00:00";
      const total = Math.max(0, Math.round(sec));
      const minutes = Math.floor(total / 60);
      const seconds = total % 60;
      return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    }

    function toSeconds(timeStr) {
      if (typeof timeStr === "number") return normalizeToSeconds(timeStr);
      if (!timeStr) return 0;
      const parts = timeStr.split(":").map(Number);
      if (parts.length === 2) return parts[0] * 60 + parts[1];
      if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
      return Number(timeStr) || 0;
    }

    function updateProgress() {
      // Progress display removed; keep counts for potential analytics.
    }

    function lockVideoControls() {
      const blocker = document.getElementById("blocker");
      blocker.style.display = "block";
      player.controls = false;          // hide native controls
      player.pause();                   // ensure paused
    }

    function unlockVideoControls() {
      const blocker = document.getElementById("blocker");
      blocker.style.display = "none";
      player.controls = true;           // restore controls
    }



    // Init
    loadVideos();


  </script>
</body>

</html>






