<!DOCTYPE html>
<html>
<head>
  <title>Kids Video Quiz</title>
  <script src="https://www.youtube.com/iframe_api"></script>
  <style>
    body {
      display: flex;
      font-family: Arial, sans-serif;
    }

    /* -------- SIDEBAR STYLES -------- */
    #sidebar {
      width: 250px;
      border-left: 2px solid #ddd;
      padding: 15px;
      background: #f9f9f9;
      overflow-y: auto;
      max-height: 100vh;
    }
    #sidebar h3 { margin-top: 0; }
    #sidebar ul { list-style: none; padding: 0; }
    #sidebar li { margin-bottom: 10px; font-size: 0.9em; }
    #sidebar a { color: #0077cc; text-decoration: none; cursor: pointer; }
    #sidebar a:hover { text-decoration: underline; }
    /* -------------------------------- */

    #main-content { flex: 1; padding: 20px; }
    #question-box {
      margin-top: 20px;
      display: none;
      border: 2px solid #444;
      padding: 12px;
      border-radius: 8px;
      max-width: 700px;
      background: #f8f8f8;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    #feedback { margin-top: 8px; font-weight: bold; }
    #timestamp { margin-top: 4px; font-size: 0.9em; color: #555; font-style: italic; }
  </style>
</head>
<body>
  <div id="main-content">
    <h1>Kids Video Quiz</h1>

    <!-- YouTube player -->
    <div id="player"></div>

    <!-- Question box -->
    <div id="question-box">
      <h3 id="question"></h3>
      <p id="timestamp"></p>
      <p id="feedback"></p>
    </div>
  </div>

  <!-- Sidebar -->
  <div id="sidebar">
    <h3>üìù Questions</h3>
    <ul id="question-list"></ul>
  </div>

  <script>
    let player;
    let segments = {};
    let asked = new Set();         // stores integer seconds for correctly answered questions
    let checkInterval = null;
    let activeQuestion = false;
    let previousTime = 0;

    // Skip-lock variables
    let maxAllowedTime = 0;     
    let skipLockBypass = false;

    // Rewind buffers (seconds)
    const REWIND_BEFORE_SEGMENT_BUFFER = 2;   // fallback when no prior correct question in segment
    const REWIND_AFTER_CORRECT_BUFFER = 1;   // rewind to lastCorrect + this

    // Load questions.json
    fetch("/static/questions.json?nocache=" + Date.now())
      .then(response => response.json())
      .then(data => {
        segments = data;
        console.log("‚úÖ Loaded questions.json:", segments);
        populateSidebar();
      })
      .catch(err => console.error("‚ùå Failed to load questions.json:", err));

    function toSeconds(timeStr) {
      if (!timeStr) return 0;
      const parts = timeStr.split(":").map(Number);
      if (parts.length === 2) return parts[0] * 60 + parts[1];
      if (parts.length === 3) return parts[0]*3600 + parts[1]*60 + parts[2];
      return Number(timeStr) || 0;
    }

    function onYouTubeIframeAPIReady() {
      player = new YT.Player("player", {
        height: "390",
        width: "640",
        videoId: "zY2IwiBPchQ",
        playerVars: { controls: 1 }, // show progress bar but we block skipping
        events: { "onStateChange": onPlayerStateChange }
      });
    }

    function onPlayerStateChange(event) {
      if (event.data == YT.PlayerState.PLAYING && !checkInterval) {
        previousTime = Math.floor(player.getCurrentTime());
        checkInterval = setInterval(() => {
          let currentTime = Math.floor(player.getCurrentTime());

          // ---------- Skip-lock detection ----------
          if (!skipLockBypass) {
            if (currentTime > maxAllowedTime + 2) {
              console.warn("‚è™ Skip attempt detected! Resetting to maxAllowedTime:", maxAllowedTime);
              player.seekTo(maxAllowedTime, true);
              return;
            }
          } else {
            // a sidebar jump happened; allow it once and reset bypass
            skipLockBypass = false;
          }
          // Update the maximum allowed time watched
          if (currentTime > maxAllowedTime) maxAllowedTime = currentTime;
          // -----------------------------------------

          if (activeQuestion) {
            previousTime = currentTime;
            return;
          }

          // Loop through segments and questions, using crossing detection
          for (let segKey in segments) {
            let segment = segments[segKey];
            let segStart = toSeconds(segment.segment_range_start);
            let segEnd = toSeconds(segment.segment_range_end);

            for (let key in segment) {
              if (!key.startsWith("question_")) continue;
              let q = segment[key];
              let quesTime = toSeconds(q.ques_time);

              // trigger only when we cross the quesTime and it's not already correctly answered
              if (previousTime < quesTime && currentTime >= quesTime && !asked.has(quesTime)) {
                console.log("üéØ Asking:", q.question, "at", q.ques_time, "(sec:", quesTime, ")");
                // pass segStart and segEnd so rewind logic can compute within-segment last-correct
                askQuestion(q, segStart, segEnd);
                previousTime = currentTime;
                return; // only ask one question at a time
              }
            }
          }

          previousTime = currentTime;
        }, 700); // slightly faster check for responsiveness
      }

      if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
        if (checkInterval) {
          clearInterval(checkInterval);
          checkInterval = null;
        }
      }
    }

    // askQuestion now receives segStart and segEnd so startListening can refer to the segment bounds
    function askQuestion(q, segStart, segEnd) {
      activeQuestion = true;
      player.pauseVideo();

      document.getElementById("question-box").style.display = "block";
      document.getElementById("question").innerText = q.question;
      document.getElementById("timestamp").innerHTML =
        `‚è± Appears at <a onclick="seekWithBypass(${toSeconds(q.ques_time)})">${q.ques_time}</a>`;
      document.getElementById("feedback").innerText = "";

      let utter = new SpeechSynthesisUtterance(q.question);
      // pass segStart and segEnd to startListening so the wrong-answer rewind logic can scope to the segment
      utter.onend = () => startListening(q, segStart, segEnd);
      speechSynthesis.speak(utter);
    }
    

    // START LISTENING: if wrong, rewind to just after last correctly answered question in this segment
    function startListening(q, segStart, segEnd) {
      let SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRec) {
        document.getElementById("feedback").innerText = "Speech recognition not supported in this browser.";
        setTimeout(() => {
          activeQuestion = false;
          document.getElementById("question-box").style.display = "none";
          player.playVideo();
        }, 1200);
        return;
      }

      let recognition = new SpeechRec();
      recognition.lang = "en-US";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.start();

      recognition.onresult = (event) => {
        let spoken = event.results[0][0].transcript.toLowerCase();
        console.log("üé§ Heard:", spoken);

        const quesSec = toSeconds(q.ques_time);
        // Find previously-correct answers inside this same segment
        const askedArr = Array.from(asked || []);
        const askedInSegment = askedArr.filter(t => t >= segStart && t <= segEnd);

        if (spoken.includes(q.answer.toLowerCase())) {
          // Correct: mark as done and resume
          document.getElementById("feedback").innerText = "‚úÖ Congratulations, correct!";
          asked.add(quesSec);
          activeQuestion = false;
          // hide question then resume shortly
          setTimeout(() => {
            document.getElementById("question-box").style.display = "none";
            // resume playing; previousTime is reset on next interval tick
            player.playVideo();
          }, 700);
        } else {
          // Wrong: compute rewind target
          console.log("‚ùå Wrong answer. askedInSegment:", askedInSegment);
          let rewindTo;
          if (askedInSegment.length > 0) {
            const lastAnswered = Math.max(...askedInSegment);
            // rewind to just after lastAnswered, but ensure we rewind before the current question
            rewindTo = Math.min(lastAnswered + REWIND_AFTER_CORRECT_BUFFER, Math.max(segStart, quesSec - 1));
            if (rewindTo < segStart) rewindTo = segStart;
            console.log("Rewinding to just after last correct in segment:", lastAnswered, "-> seek to", rewindTo);
          } else {
            // no previous correct in this segment: revert to segment start (with optional small buffer before it)
            // we choose segStart (you can subtract REWIND_BEFORE_SEGMENT_BUFFER if you prefer earlier context)
            rewindTo = Math.max(0, segStart);
            console.log("No previous correct in segment ‚Äî rewinding to segment start:", rewindTo);
          }

          document.getElementById("feedback").innerText = "‚ùå Sorry, wrong answer. Rewinding...";
          // Seek to the computed time and resume
          player.seekTo(rewindTo, true);

          // update previousTime so the crossing detection doesn't immediately re-trigger
          previousTime = Math.floor(rewindTo);

          // unlock and resume after a short pause so the user can hear context
          setTimeout(() => {
            document.getElementById("question-box").style.display = "none";
            activeQuestion = false;
            player.playVideo();
          }, 800);
        }
      };

      recognition.onerror = (event) => {
        console.error("‚ö†Ô∏è Speech recognition error:", event.error);
        document.getElementById("feedback").innerText = "Could not hear you clearly ‚Äî try again.";
        setTimeout(() => {
          activeQuestion = false;
          document.getElementById("question-box").style.display = "none";
          player.playVideo();
        }, 1000);
      };
    }

    // -------- SIDEBAR POPULATOR --------
    function populateSidebar() {
      const list = document.getElementById("question-list");
      list.innerHTML = "";

      for (let seg in segments) {
        let segment = segments[seg];
        for (let key in segment) {
          if (key.startsWith("question_")) {
            let q = segment[key];
            let li = document.createElement("li");
            // show segment key, clickable timestamp (bypasses skip lock), and question text
            li.innerHTML = `
              <strong>${seg}</strong> ‚Äî 
              <a onclick="seekWithBypass(${toSeconds(q.ques_time)})">${q.ques_time}</a>
              <br>
              ${q.question}
            `;
            list.appendChild(li);
          }
        }
      }
    }

    // Helper for sidebar clicks (bypasses skip lock)
    function seekWithBypass(seconds) {
      skipLockBypass = true;
      player.seekTo(seconds, true);
    }
  </script>
</body>
</html>
